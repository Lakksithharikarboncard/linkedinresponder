====================================================================================================
LINKEDIN AUTORESPONDER - COMPLETE SOURCE CODE
Generated: 2026-01-04T13:13:40.716Z
Total Files: 13
====================================================================================================



====================================================================================================
FILE: src/background/background.ts
====================================================================================================

import { getBotSettings } from "../shared/settings";

let botEnabled = false;

async function initialize() {
  const result = await chrome.storage.local.get(["botEnabled"]);
  botEnabled = result.botEnabled ?? false;
  console.log(`[Background] Initialized. Bot enabled: ${botEnabled}`);
}
initialize();

chrome.storage.onChanged.addListener((changes, areaName) => {
  if (areaName !== "local") return;
  if (changes.botEnabled !== undefined) {
    botEnabled = changes.botEnabled.newValue ?? false;
    console.log(`[Background] Bot enabled changed: ${botEnabled}`);
  }
});

const SCAN_ALARM_NAME = "linkedin-scan";
const SCAN_INTERVAL_MINUTES = 5;

// Guard against duplicate alarms on worker restarts
chrome.alarms.get(SCAN_ALARM_NAME, (existing) => {
  if (!existing) {
    chrome.alarms.create(SCAN_ALARM_NAME, { periodInMinutes: SCAN_INTERVAL_MINUTES });
  }
});

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === SCAN_ALARM_NAME && botEnabled) {
    console.log("[Background] Alarm triggered, running scan...");
    triggerScanOnLinkedInTabs();
  }
});

async function triggerScanOnLinkedInTabs() {
  try {
    const tabs = await chrome.tabs.query({ url: "https://www.linkedin.com/messaging/*" });

    if (tabs.length === 0) {
      console.log("[Background] No LinkedIn messaging tabs found");
      return;
    }

    for (const tab of tabs) {
      if (tab.id !== undefined) {
        chrome.tabs.sendMessage(tab.id, { type: "CHECK_UNREAD" }).catch((err) => {
          console.log(`[Background] Could not message tab ${tab.id}:`, err.message);
        });
      }
    }

    console.log(`[Background] Sent CHECK_UNREAD to ${tabs.length} tab(s)`);
  } catch (err) {
    console.error("[Background] Scan failed:", err);
  }
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  handleMessage(message, sender, sendResponse);
  return true;
});

async function handleMessage(
  message: { type: string; [key: string]: any },
  sender: chrome.runtime.MessageSender,
  sendResponse: (response: any) => void
) {
  const { type } = message;

  switch (type) {
    case "PING_BOT":
      sendResponse({ status: botEnabled ? "running" : "stopped" });
      break;

    case "START_BOT":
      botEnabled = true;
      await chrome.storage.local.set({ botEnabled: true });
      console.log("[Background] Bot started via message");
      sendResponse({ status: "running" });
      break;

    case "STOP_BOT":
      botEnabled = false;
      await chrome.storage.local.set({ botEnabled: false });
      console.log("[Background] Bot stopped via message");
      sendResponse({ status: "stopped" });
      break;

    case "RUN_SCAN_NOW":
      if (botEnabled) {
        triggerScanOnLinkedInTabs();
        sendResponse({ status: "running" });
      } else {
        sendResponse({ status: "stopped" });
      }
      break;

    case "GET_SETTINGS":
      try {
        const settings = await getBotSettings();
        sendResponse({ status: "ok", settings });
      } catch (err) {
        sendResponse({ status: "error", error: String(err) });
      }
      break;

    case "TEST_API_KEY":
      await handleTestApiKey(
        { provider: message.provider, key: message.key },
        sendResponse
      );
      break;

    default:
      console.log(`[Background] Unknown message type: ${type}`);
      sendResponse({ status: "unknown" });
  }
}

// API key testing (bypasses CORS for options page)
async function handleTestApiKey(
  message: { provider: string; key: string },
  sendResponse: (response: any) => void
) {
  const { provider, key } = message;

  if (!key?.trim()) {
    sendResponse({ success: false, message: "Key is empty" });
    return;
  }

  const endpoints: Record<string, string> = {
    openai: "https://api.openai.com/v1/models",
    groq: "https://api.groq.com/openai/v1/models",
  };

  const url = endpoints[provider];
  if (!url) {
    sendResponse({ success: false, message: "Unknown provider" });
    return;
  }

  try {
    const response = await fetch(url, {
      method: "GET",
      headers: { Authorization: `Bearer ${key}` },
    });

    const msg = `${response.status} ${response.statusText}${response.status === 429 ? " (rate limited)" : ""}`;
    sendResponse({ success: response.ok, message: msg });
  } catch (err: any) {
    sendResponse({ success: false, message: err?.message || "Request failed" });
  }
}

chrome.runtime.onInstalled.addListener((details) => {
  console.log(`[Background] Extension installed/updated: ${details.reason}`);
  chrome.alarms.get(SCAN_ALARM_NAME, (alarm) => {
    if (!alarm) {
      chrome.alarms.create(SCAN_ALARM_NAME, { periodInMinutes: SCAN_INTERVAL_MINUTES });
      console.log("[Background] Scan alarm created");
    }
  });
});

====================================================================================================
FILE: src/content/content.ts
====================================================================================================

// src/content/content.ts
import { BotCommand, BotLogEntry, BotStats, BotStatus, MessageEntry, ConversationHistory } from "../shared/types";
import { checkPositiveLead, sendLeadWebhook, shouldReplyToConversation, shouldEngageAfterClose, LeadWebhookPayload } from "../shared/sendEmail";
import { generateLeadId, loadConversation, saveConversation, shouldResync } from "../shared/conversationStorage";
import { scrapeLeadProfile, formatProfileForDisplay, formatProfileForAI } from "../shared/profileScraper";
import { shouldDoubleText, generateDoubleText, calculateDoubleTextDelay } from "../shared/doubleTextHandler";
import { getBotSettings, AIProvider } from "../shared/settings";

type ContentCommand =
  | BotCommand
  | { type: "PING_TEST" }
  | { type: "CHECK_UNREAD" }
  | { type: "PAUSE_BOT" }
  | { type: "RESUME_BOT" }
  | { type: "APPROVE_REPLY"; reply: string; leadName: string }
  | { type: "REJECT_REPLY"; leadName: string };

// --- STATE VARIABLES ---
let botRunning = false;
let botPaused = false;
let botLoopTimeout: number | null = null;
let stats: BotStats = {
  chatsProcessed: 0,
  repliesSent: 0,
  leadsFound: 0,
  startTime: null,
  tokensUsed: 0,
  currentModel: "",
};
let logs: BotLogEntry[] = [];
let useStrictHours = true;
let groqModel = "llama-3.3-70b-versatile";
let replyPreviewEnabled = false;
let pendingReplyResolve: ((approved: { approved: boolean; reply: string }) => void) | null = null;
let blacklist: string[] = [];

// --- CONSTANTS ---
const HEADLINE_BLACKLIST = ["student", "intern", "seeking", "open to work", "looking for", "hiring"];
const CLOSE_COOLDOWN_MS = 14 * 24 * 60 * 60 * 1000;

const MY_CLOSE_PATTERNS = [
  "no overlap", "not a fit", "reach out if", "feel free to reach out",
  "thanks for letting me know", "happy to stay connected", "best of luck",
  "good luck with", "wishing you", "take care", "all the best",
  "not what you're looking for", "doesn't seem like a match", "maybe in the future", "keep in touch",
];

const POSITIVE_SCHEDULING_CONTEXT = [
  "schedule", "reschedule", "next week", "after jan", "after january",
  "after the", "let's", "lets", "call", "meet", "demo", "walkthrough",
  "chat soon", "talk soon", "talk then", "sounds good", "works for me",
  "perfect", "great", "book", "calendar", "calendly", "outlook",
];

const SOFT_POSITIVE_PATTERNS = ["no problem", "no worries", "sure thing", "of course", "absolutely", "definitely"];

const SCHEDULING_PATTERNS = [
  "calendly.com", "cal.com", "outlook.office.com/book", "hubspot.com/meetings",
  "savvycal.com", "tidycal.com", "book a time", "grab time", "schedule a call",
  "schedule a chat", "book a call", "here's a link", "here is a link",
  "whenever works", "pick a time", "find a time",
];

const LEAD_CONFIRMATION_PATTERNS = [
  "sounds good", "sounds great", "perfect", "will do", "see you then",
  "looking forward", "look forward", "talk soon", "talk then", "catch you",
  "thanks for sharing", "thank you for sharing", "i'll check", "i will check",
  "let me check", "booked", "scheduled", "confirmed", "done", "great, thanks",
  "awesome", "cool", "ok great", "okay great", "works for me",
];

const SHORT_PING_PATTERNS = [
  "hi", "hey", "hello", "hii", "hiii", "heyy", "heyyy", "yo", "sup",
  "morning", "good morning", "good afternoon", "good evening", "gm",
];

const RESCHEDULE_REASON_PATTERNS = [
  { pattern: "vacation", reason: "vacation" },
  { pattern: "holiday", reason: "holiday" },
  { pattern: "traveling", reason: "traveling" },
  { pattern: "travel", reason: "travel" },
  { pattern: "out of office", reason: "out of office" },
  { pattern: "out of town", reason: "out of town" },
  { pattern: "busy", reason: "busy schedule" },
  { pattern: "swamped", reason: "busy schedule" },
  { pattern: "hectic", reason: "busy schedule" },
  { pattern: "next week", reason: "timing" },
  { pattern: "after the", reason: "timing" },
  { pattern: "after jan", reason: "new year" },
  { pattern: "after january", reason: "new year" },
  { pattern: "new year", reason: "new year" },
];

// --- HELPERS ---
function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}

function delay(ms: number) {
  return new Promise<void>((res) => setTimeout(res, ms));
}

async function fetchWithBackoff(fn: () => Promise<Response>, maxRetries = 3, baseDelayMs = 1000): Promise<Response> {
  let attempt = 0;
  while (true) {
    const res = await fn();
    if (res.ok) return res;
    if ((res.status === 429 || res.status >= 500) && attempt < maxRetries) {
      const backoffDelay = baseDelayMs * 2 ** attempt + Math.random() * 400;
      await sleep(backoffDelay);
      attempt++;
      continue;
    }
    return res;
  }
}

function addLog(type: "INFO" | "ACTION" | "ERROR" | "SUCCESS" | "WARNING", message: string, actor: "User" | "Bot" | "System") {
  const entry: BotLogEntry = { time: Date.now(), type, message, actor };
  logs.unshift(entry);
  if (logs.length > 100) logs.pop();
  chrome.storage.local.set({ botLog: logs.slice(0, 50) });
}

function updateStats(key: keyof BotStats, value: number | string) {
  if (key === "startTime") stats.startTime = value as number;
  else if (key === "currentModel") stats.currentModel = value as string;
  else (stats[key] as number) += value as number;
}

function calculateTypingDelay(text: string): number {
  return 2000 + text.split(" ").length * 300 + Math.random() * 2000;
}

function isWithinWorkingHours(startHour: number = 9, endHour: number = 18): boolean {
  const currentHour = new Date().getHours();
  return currentHour >= startHour && currentHour < endHour;
}

async function setEditableText(input: HTMLElement, text: string) {
  input.focus();
  await delay(50);
  document.execCommand("selectAll", false, "");
  document.execCommand("delete", false, "");
  for (const char of text) {
    document.execCommand("insertText", false, char);
    await delay(Math.random() > 0.9 ? 150 : 30 + Math.random() * 50);
  }
}

async function humanScroll() {
  const pane = document.querySelector<HTMLElement>(".msg-s-message-list-content");
  if (!pane) return;
  pane.scrollBy(0, Math.random() * 80 + 20);
  await delay(300 + Math.random() * 500);
  pane.scrollBy(0, -(Math.random() * 50 + 10));
  await delay(300 + Math.random() * 500);
}

async function scrollConversationList(times: number = 5) {
  const container = document.querySelector<HTMLElement>(".msg-conversations-container--inbox-shortcuts");
  if (!container) return;
  for (let i = 0; i < times; i++) {
    container.scrollBy({ top: Math.random() * 200 + 100, behavior: "smooth" });
    await delay(500 + Math.random() * 800);
    container.scrollBy({ top: -(Math.random() * 50), behavior: "smooth" });
    await delay(400 + Math.random() * 500);
  }
}

function getApiKeyForProvider(provider: AIProvider, apiKey: string, groqApiKey: string): string {
  return provider === "groq" ? groqApiKey : apiKey;
}

async function getSettings() {
  const s = await getBotSettings();
  return {
    apiKey: s.openaiApiKey,
    groqApiKey: s.groqApiKey,
    chatMin: s.chatMinDelay,
    chatMax: s.chatMaxDelay,
    loopMin: s.loopMinDelay,
    loopMax: s.loopMaxDelay,
    prompt: s.replyPrompt,
    leadPrompt: s.leadPrompt,
    webhookUrl: s.webhookUrl,
    startHour: s.startHour,
    endHour: s.endHour,
    replyProvider: s.replyProvider,
    decisionProvider: s.decisionProvider,
    leadDetectionProvider: s.leadDetectionProvider,
  };
}

function getLeadName(): string | null {
  const el = document.evaluate(
    '//*[@id="thread-detail-jump-target"]/div/a/div/dl/dt/h2',
    document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null
  ).singleNodeValue as HTMLElement | null;
  return el?.textContent?.trim() || null;
}

function getLeadProfileUrl(): string {
  const profileLink = document.querySelector<HTMLAnchorElement>('a[href*="/in/"]');
  return profileLink?.href || window.location.href;
}

// Fixed: Handle LinkedIn's grouped messages
function getLastMessage(leadName: string): { fromLead: boolean; content: string } | null {
  const events = Array.from(document.querySelectorAll("li.msg-s-message-list__event"));
  let currentSender: string | null = null;
  const allMessages: Array<{ sender: string; content: string }> = [];

  for (const msgEl of events) {
    const senderEl = msgEl.querySelector("span.msg-s-message-group__name");
    const contentEl = msgEl.querySelector("p.msg-s-event-listitem__body");
    if (senderEl) currentSender = senderEl.textContent?.trim() || null;
    if (contentEl && currentSender) {
      const content = contentEl.textContent?.trim() || "";
      if (content) allMessages.push({ sender: currentSender, content });
    }
  }

  if (allMessages.length === 0) return null;
  const lastMsg = allMessages[allMessages.length - 1];
  return { fromLead: lastMsg.sender.includes(leadName), content: lastMsg.content };
}

// Get recent messages from lead for AI decision
function getRecentLeadMessages(leadName: string, count: number = 5): string[] {
  const events = Array.from(document.querySelectorAll("li.msg-s-message-list__event"));
  let currentSender: string | null = null;
  const leadMessages: string[] = [];

  for (const msgEl of events) {
    const senderEl = msgEl.querySelector("span.msg-s-message-group__name");
    const contentEl = msgEl.querySelector("p.msg-s-event-listitem__body");
    if (senderEl) currentSender = senderEl.textContent?.trim() || null;
    if (contentEl && currentSender && currentSender.includes(leadName)) {
      const content = contentEl.textContent?.trim() || "";
      if (content) leadMessages.push(content);
    }
  }

  return leadMessages.slice(-count);
}

async function scrollToLoadAllMessages() {
  const messagePane = document.querySelector<HTMLElement>(".msg-s-message-list-content");
  if (!messagePane) return;
  let previousHeight = 0;
  let currentHeight = messagePane.scrollHeight;
  let attempts = 0;
  addLog("INFO", "Loading full conversation history...", "System");
  while (currentHeight > previousHeight && attempts < 50) {
    previousHeight = currentHeight;
    messagePane.scrollTo({ top: 0, behavior: "smooth" });
    await delay(800 + Math.random() * 400);
    currentHeight = messagePane.scrollHeight;
    attempts++;
  }
  addLog("INFO", `Loaded ${attempts} message batches`, "System");
}

// Fixed: Handle grouped messages
async function getCompleteConversation(leadName: string): Promise<MessageEntry[]> {
  await scrollToLoadAllMessages();
  const events = Array.from(document.querySelectorAll("li.msg-s-message-list__event"));
  const messages: MessageEntry[] = [];
  let currentSender: string | null = null;

  for (const msgEl of events) {
    const senderEl = msgEl.querySelector("span.msg-s-message-group__name");
    const contentEl = msgEl.querySelector("p.msg-s-event-listitem__body");
    const timeEl = msgEl.querySelector("time");

    if (senderEl) currentSender = senderEl.textContent?.trim() || null;
    if (contentEl && currentSender) {
      const content = contentEl.textContent?.trim() || "";
      let timestamp = Date.now();
      if (timeEl) {
        const dt = timeEl.getAttribute("datetime");
        if (dt) timestamp = new Date(dt).getTime();
      }
      if (content) {
        messages.push({
          speaker: currentSender,
          content,
          timestamp,
          type: currentSender.includes(leadName) ? "received" : "sent",
        });
      }
    }
  }
  return messages;
}

async function getOrCreateConversationHistory(leadName: string): Promise<ConversationHistory> {
  const profileUrl = getLeadProfileUrl();
  const leadId = generateLeadId(leadName, profileUrl);
  let existingConvo = await loadConversation(leadId);

  if (existingConvo && !shouldResync(existingConvo)) {
    addLog("INFO", `Using cached data for ${formatProfileForDisplay(leadName, existingConvo.profile)} (${existingConvo.messages.length} msgs)`, "System");
    return existingConvo;
  }

  addLog("INFO", `Scraping profile for ${leadName}...`, "System");
  const profileData = scrapeLeadProfile();
  addLog("INFO", `Syncing full history for ${leadName}...`, "System");
  const freshMessages = await getCompleteConversation(leadName);
  const lastMsg = freshMessages[freshMessages.length - 1];

  const conversation: ConversationHistory = {
    leadId,
    leadName,
    profileUrl,
    profile: profileData,
    messages: freshMessages,
    metadata: {
      firstContact: freshMessages[0]?.timestamp || Date.now(),
      lastActivity: lastMsg?.timestamp || Date.now(),
      lastMessageFrom: lastMsg?.type === "received" ? "lead" : "me",
      totalMessages: freshMessages.length,
      lastSyncedAt: Date.now(),
    },
  };

  await saveConversation(conversation);
  addLog("SUCCESS", `Saved ${freshMessages.length} messages + profile for ${formatProfileForDisplay(leadName, profileData)}`, "System");
  return conversation;
}

function containsSchedulingLink(content: string): boolean {
  const lower = content.toLowerCase();
  return SCHEDULING_PATTERNS.some((p) => lower.includes(p));
}

function isLeadConfirmation(content: string): boolean {
  const lower = content.toLowerCase().trim();
  if (lower.split(/\s+/).length > 10) return false;
  return LEAD_CONFIRMATION_PATTERNS.some((p) => lower.includes(p));
}

function isShortPing(content: string): boolean {
  const lower = content.toLowerCase().trim();
  if (lower.split(/\s+/).length > 3) return false;
  return SHORT_PING_PATTERNS.some((p) => lower === p || lower.startsWith(p + " "));
}

function hasPositiveSchedulingContext(content: string): boolean {
  return POSITIVE_SCHEDULING_CONTEXT.some((p) => content.toLowerCase().includes(p));
}

function isSoftPositiveInContext(content: string): boolean {
  const lower = content.toLowerCase();
  return SOFT_POSITIVE_PATTERNS.some((p) => lower.includes(p)) && hasPositiveSchedulingContext(content);
}

function getPendingMeetingTimestamp(messages: MessageEntry[]): number | null {
  for (let i = messages.length - 1; i >= 1; i--) {
    const curr = messages[i];
    const prev = messages[i - 1];
    if (prev.type === "sent" && curr.type === "received" && containsSchedulingLink(prev.content) && isLeadConfirmation(curr.content)) {
      return curr.timestamp;
    }
    if (i >= 2) {
      const prevPrev = messages[i - 2];
      if (prevPrev.type === "received" && prev.type === "sent" && curr.type === "received") {
        const ppLower = prevPrev.content.toLowerCase();
        if ((ppLower.includes("schedule") || ppLower.includes("after") || ppLower.includes("next week") || ppLower.includes("vacation") || ppLower.includes("holiday")) && isLeadConfirmation(curr.content)) {
          return curr.timestamp;
        }
      }
    }
  }
  return null;
}

function getMyCloseTimestamp(messages: MessageEntry[]): number | null {
  for (let i = messages.length - 1; i >= 0; i--) {
    const m = messages[i];
    if (m.type === "sent") {
      const lower = m.content.toLowerCase();
      if (hasPositiveSchedulingContext(m.content) || isSoftPositiveInContext(m.content)) continue;
      if (MY_CLOSE_PATTERNS.some((p) => lower.includes(p))) return m.timestamp;
    }
  }
  return null;
}

interface ConversationCloseState {
  isClosed: boolean;
  closeType: "none" | "my_close" | "pending_meeting";
  closeTimestamp: number | null;
  reason: string;
}

function getConversationCloseState(messages: MessageEntry[]): ConversationCloseState {
  const pendingTs = getPendingMeetingTimestamp(messages);
  if (pendingTs) return { isClosed: true, closeType: "pending_meeting", closeTimestamp: pendingTs, reason: "Meeting scheduled" };

  const myCloseTs = getMyCloseTimestamp(messages);
  if (myCloseTs) return { isClosed: true, closeType: "my_close", closeTimestamp: myCloseTs, reason: "I closed the conversation" };

  return { isClosed: false, closeType: "none", closeTimestamp: null, reason: "" };
}

// âœ… NEW: AI-based skip decision
async function shouldSkipDueToCloseState(
  closeState: ConversationCloseState,
  recentLeadMessages: string[],
  apiKey: string,
  provider: AIProvider
): Promise<{ shouldSkip: boolean; reason: string }> {
  if (!closeState.isClosed || !closeState.closeTimestamp) {
    return { shouldSkip: false, reason: "" };
  }

  const timeSinceClose = Date.now() - closeState.closeTimestamp;
  const daysSinceClose = Math.round(timeSinceClose / (1000 * 60 * 60 * 24));

  // Use AI to decide
  addLog("INFO", `Checking engagement with AI (${daysSinceClose} days since close)...`, "System");

  const result = await shouldEngageAfterClose(
    apiKey,
    recentLeadMessages,
    closeState.closeType,
    daysSinceClose,
    provider
  );

  return {
    shouldSkip: !result.shouldEngage,
    reason: result.reason,
  };
}

function headlineIsIrrelevant(headline: string): boolean {
  if (!headline || headline === "Unknown") return true;
  return HEADLINE_BLACKLIST.some((w) => headline.toLowerCase().includes(w));
}

function detectKeyEvents(messages: MessageEntry[]) {
  const now = Date.now();
  const lastMsg = messages[messages.length - 1];
  const lastActivity = lastMsg?.timestamp || now;
  const daysSinceLastActivity = Math.floor((now - lastActivity) / (1000 * 60 * 60 * 24));

  let schedulingLinkSent = false;
  let schedulingLinkTimestamp: number | null = null;
  let leadConfirmedInterest = false;
  let reschedulingRequested = false;
  let reschedulingReason: string | null = null;
  let leadShowedStrongInterest = false;

  for (const msg of messages) {
    const lower = msg.content.toLowerCase();
    if (msg.type === "sent" && containsSchedulingLink(msg.content)) {
      schedulingLinkSent = true;
      schedulingLinkTimestamp = msg.timestamp;
    }
    if (msg.type === "received") {
      if (isLeadConfirmation(msg.content)) leadConfirmedInterest = true;
      if (["tell me more", "interested", "sounds interesting", "would be great", "please", "yes please", "walkthrough", "demo", "show me"].some((s) => lower.includes(s))) {
        leadShowedStrongInterest = true;
      }
      for (const { pattern, reason } of RESCHEDULE_REASON_PATTERNS) {
        if (lower.includes(pattern)) {
          reschedulingRequested = true;
          reschedulingReason = reason;
          break;
        }
      }
    }
  }

  return {
    schedulingLinkSent,
    schedulingLinkTimestamp,
    leadConfirmedInterest,
    reschedulingRequested,
    reschedulingReason,
    daysSinceLastActivity,
    lastMessageIsShortPing: lastMsg ? isShortPing(lastMsg.content) : false,
    iSentLastMessage: lastMsg?.type === "sent",
    leadShowedStrongInterest,
  };
}

function buildConversationContext(messages: MessageEntry[], closeState: ConversationCloseState, leadName: string) {
  const keyEvents = detectKeyEvents(messages);
  const msgCount = messages.length;
  let state = "active";
  let stateDescription = "";
  let keyContextSummary = "";
  let responseGuidance = "";

  if (msgCount < 4) {
    state = "new";
    stateDescription = "New conversation - still building rapport";
    keyContextSummary = "This is a fresh conversation.";
    responseGuidance = "Be friendly and conversational. Don't push too hard - build rapport first.";
  } else if (closeState.closeType === "pending_meeting") {
    state = "pending_meeting";
    if (keyEvents.reschedulingRequested && keyEvents.reschedulingReason) {
      stateDescription = `Pending meeting - they asked to reschedule due to ${keyEvents.reschedulingReason}`;
      keyContextSummary = `You sent a scheduling link. They asked to reschedule. Now they're back.`;
      responseGuidance = keyEvents.lastMessageIsShortPing
        ? `Be warm and welcoming. Reference their break. Ask if they're ready to schedule.`
        : `Answer their questions and offer to schedule.`;
    } else {
      stateDescription = "Pending meeting - scheduling link sent";
      keyContextSummary = "You already sent a scheduling link and they showed interest.";
      responseGuidance = "Be helpful. Acknowledge warmly and offer to help schedule.";
    }
  } else if (closeState.closeType === "my_close") {
    state = "closed";
    stateDescription = "Conversation was closed/declined";
    keyContextSummary = "You previously closed this conversation politely.";
    responseGuidance = "Be polite but brief. Don't re-pitch aggressively.";
  } else if (keyEvents.daysSinceLastActivity > 14) {
    state = "re_engaging";
    stateDescription = `Re-engaging after ${keyEvents.daysSinceLastActivity} days`;
    keyContextSummary = `It's been ${keyEvents.daysSinceLastActivity} days since the last message.`;
    responseGuidance = "Acknowledge the time gap briefly. Don't be pushy.";
  } else {
    state = "active";
    stateDescription = keyEvents.leadShowedStrongInterest ? "Active - lead has shown strong interest" : "Active conversation";
    keyContextSummary = "Ongoing conversation.";
    responseGuidance = "Be helpful and natural. Match their energy.";
  }

  if (keyEvents.lastMessageIsShortPing && state !== "pending_meeting") {
    responseGuidance += " Their last message was a short greeting - respond warmly first.";
  }

  return { state, stateDescription, keyContextSummary, responseGuidance };
}

async function fetchReply(
  apiKey: string,
  prompt: string,
  fullHistory: MessageEntry[],
  leadName: string,
  myName: string,
  leadProfile: any,
  useGroqAPI: boolean = false,
  groqModelName: string = "llama-3.3-70b-versatile",
  closeState?: ConversationCloseState
): Promise<{ reply: string; tokensUsed: number }> {
  const recentMessages = fullHistory.slice(-30);
  const conversationText = recentMessages.map((msg) => `${msg.speaker}: ${msg.content}`).join("\n");
  const conversationContext = buildConversationContext(fullHistory, closeState || { isClosed: false, closeType: "none", closeTimestamp: null, reason: "" }, leadName);
  const profileContext = leadProfile ? `\nLEAD PROFILE:\n${formatProfileForAI(leadProfile)}\n` : "";

  const userPrompt = prompt
    .replace("{extracted_text}", conversationText)
    .replace("{user_name}", leadName)
    .replace("{lead_headline}", leadProfile?.headline || "Unknown");

  const systemPrompt = `You are a real professional messaging on LinkedIn (NOT an AI assistant).
${profileContext}
=== CONVERSATION STATE ===
STATE: ${conversationContext.stateDescription}
CONTEXT: ${conversationContext.keyContextSummary}

=== RESPONSE GUIDANCE ===
${conversationContext.responseGuidance}

=== CONVERSATION HISTORY ===
${conversationText}

USER'S INSTRUCTIONS:
${userPrompt}

CRITICAL RULES:
1. LENGTH: 15-30 words. Be concise.
2. TONE: Match their energy.
3. NATURAL: Use contractions. Be conversational.
4. If they say "hi" or "how are you", respond warmly FIRST, then ask how you can help.
5. Don't immediately send links after a greeting.
6. Reference shared context naturally.

Respond as ${myName}.`;

  const apiUrl = useGroqAPI ? "https://api.groq.com/openai/v1/chat/completions" : "https://api.openai.com/v1/chat/completions";
  const model = useGroqAPI ? groqModelName : "gpt-4o-mini";
  const maxTokens = useGroqAPI ? 250 : 150;

  const response = await fetchWithBackoff(() =>
    fetch(apiUrl, {
      method: "POST",
      headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
      body: JSON.stringify({
        model,
        messages: [
          { role: "system", content: systemPrompt },
          ...recentMessages.map((msg) => ({ role: msg.type === "received" ? "user" : "assistant", content: msg.content })),
        ],
        max_tokens: maxTokens,
        temperature: 0.7,
      }),
    }), 3, 1000
  );

  if (!response.ok) {
    const bodyText = await response.text();
    throw new Error(`API Error ${response.status}: ${bodyText.slice(0, 500)}`);
  }

  const data = await response.json();
  const tokensUsed = (data.usage?.prompt_tokens || 0) + (data.usage?.completion_tokens || 0);
  return { reply: data.choices[0].message.content.trim(), tokensUsed };
}

function getMyName(): string {
  const nameEl = document.querySelector(".global-nav__me-content span") as HTMLElement;
  return nameEl?.textContent?.trim() || "You";
}

function getModelDisplayName(modelId: string): string {
  const names: Record<string, string> = {
    "llama-3.3-70b-versatile": "Llama-3.3-70B",
    "gpt-4o-mini": "GPT-4o-mini",
    "gpt-4o": "GPT-4o",
  };
  return names[modelId] || modelId;
}

function getProviderDisplayName(provider: AIProvider): string {
  return provider === "groq" ? "Groq" : "OpenAI";
}

function isBlacklisted(leadName: string, profile: any): boolean {
  const checkStrings = [leadName.toLowerCase(), profile?.company?.toLowerCase() || "", profile?.jobTitle?.toLowerCase() || ""];
  for (const entry of blacklist) {
    const entryLower = entry.toLowerCase();
    for (const check of checkStrings) {
      if (check && check.includes(entryLower)) return true;
    }
  }
  return false;
}

async function waitForReplyApproval(leadName: string, reply: string): Promise<{ approved: boolean; reply: string }> {
  return new Promise((resolve) => {
    pendingReplyResolve = resolve;
    chrome.storage.local.set({ pendingReply: { leadName, reply, timestamp: Date.now() } });
    addLog("INFO", `Waiting for approval to reply to ${leadName}...`, "System");
    setTimeout(() => {
      if (pendingReplyResolve) {
        addLog("WARNING", `Reply approval timed out for ${leadName}`, "System");
        pendingReplyResolve({ approved: false, reply: "" });
        pendingReplyResolve = null;
        chrome.storage.local.remove(["pendingReply"]);
      }
    }, 5 * 60 * 1000);
  });
}

async function waitForElement<T extends Element>(selector: string, tries = 6, delayMs = 400): Promise<T | null> {
  for (let i = 0; i < tries; i++) {
    const el = document.querySelector<T>(selector);
    if (el) return el;
    await delay(delayMs);
  }
  return null;
}

function randomDelay(min: number, max: number) {
  return delay(Math.floor(Math.random() * (max - min + 1)) + min);
}

function getErrorMsg(err: unknown): string {
  if (typeof err === "string") return err;
  if (err && typeof err === "object" && "message" in err) return (err as any).message;
  return "Unknown error";
}

// --- MAIN LOOP ---
async function runIteration(n: number) {
  addLog("INFO", `Starting batch of ${n} chats...`, "System");

  const { apiKey, groqApiKey, chatMin, chatMax, loopMin, loopMax, prompt, leadPrompt, webhookUrl, startHour, endHour, replyProvider, decisionProvider, leadDetectionProvider } = await getSettings();

  const replyApiKey = getApiKeyForProvider(replyProvider, apiKey, groqApiKey);
  const decisionApiKey = getApiKeyForProvider(decisionProvider, apiKey, groqApiKey);
  const leadDetectionApiKey = getApiKeyForProvider(leadDetectionProvider, apiKey, groqApiKey);

  const currentModelName = replyProvider === "groq" ? groqModel : "gpt-4o-mini";
  updateStats("currentModel", getModelDisplayName(currentModelName));

  blacklist = (await chrome.storage.local.get(["blacklist"])).blacklist || [];

  if (useStrictHours && !isWithinWorkingHours(startHour, endHour)) {
    addLog("WARNING", `Outside working hours (${startHour}-${endHour}). Pausing.`, "System");
    if (botRunning && !botPaused) {
      botLoopTimeout = window.setTimeout(() => runIteration(n), 15 * 60 * 1000);
    }
    return;
  }

  const myName = getMyName();
  await scrollConversationList(5);

  let chats = Array.from(document.querySelectorAll("ul.msg-conversations-container__conversations-list li"))
    .slice(0, n)
    .sort(() => Math.random() - 0.2);

  addLog("INFO", `Found ${chats.length} conversations to check.`, "Bot");

  for (let i = 0; i < chats.length && botRunning; i++) {
    while (botPaused && botRunning) await delay(1000);
    if (!botRunning) break;

    await humanScroll();
    await randomDelay(chatMin, chatMax);
    const clickable = chats[i].querySelector<HTMLElement>("a, .msg-conversation-listitem__link, [tabindex='0']");
    clickable?.click();
    await delay(2000);

    const leadName = getLeadName();
    if (!leadName) continue;

    const lastMsg = getLastMessage(leadName);
    if (!lastMsg || !lastMsg.fromLead) {
      addLog("INFO", `Skipping ${leadName}: Last message was from me.`, "Bot");
      continue;
    }

    // Get recent messages for AI decision
    const recentLeadMessages = getRecentLeadMessages(leadName, 5);
    const fullConversation = await getOrCreateConversationHistory(leadName);
    const closeState = getConversationCloseState(fullConversation.messages);

    // âœ… AI-based skip decision
    if (closeState.isClosed) {
      const skipCheck = await shouldSkipDueToCloseState(closeState, recentLeadMessages, decisionApiKey, decisionProvider);
      if (skipCheck.shouldSkip) {
        addLog("INFO", `Skipping ${leadName}: ${skipCheck.reason} [AI/${closeState.closeType}]`, "Bot");
        continue;
      }
      addLog("INFO", `Engaging ${leadName}: ${skipCheck.reason} [AI]`, "Bot");
    }

    const headline = fullConversation.profile?.headline || "Unknown";
    if (headlineIsIrrelevant(headline) && !lastMsg.content.includes("?") && lastMsg.content.split(" ").length < 12) {
      addLog("INFO", `Skipping ${leadName}: Irrelevant headline`, "Bot");
      continue;
    }

    if (isBlacklisted(leadName, fullConversation.profile)) {
      addLog("WARNING", `Skipping ${leadName}: Blacklisted`, "Bot");
      continue;
    }

    addLog("INFO", `Checking chat with ${formatProfileForDisplay(leadName, fullConversation.profile)}...`, "Bot");
    updateStats("chatsProcessed", 1);

    if (fullConversation.messages.length === 0) {
      addLog("WARNING", `No messages found for ${leadName}`, "System");
      continue;
    }

    const recentForDecision = fullConversation.messages.slice(-8).map((m) => ({ speaker: m.speaker, message: m.content }));

    let decision;
    try {
      decision = await shouldReplyToConversation(decisionApiKey, recentForDecision, leadName, decisionProvider);
      addLog("ACTION", `AI Decision: ${decision.shouldReply ? "REPLY" : "SKIP"} (${decision.reason}) [${getProviderDisplayName(decisionProvider)}]`, "Bot");
    } catch (e) {
      addLog("ERROR", `AI Decision Failed: ${getErrorMsg(e)}`, "System");
      continue;
    }

    if (!decision.shouldReply) continue;

    // Lead detection
    if (webhookUrl) {
      try {
        const recentMsgs = fullConversation.messages.slice(-2).map((m) => m.content);
        const isPositive = await checkPositiveLead(leadDetectionApiKey, leadPrompt, recentMsgs, leadDetectionProvider);
        if (isPositive) {
          const payload: LeadWebhookPayload = {
            leadName,
            profileUrl: fullConversation.profileUrl,
            company: fullConversation.profile?.company || "Unknown",
            jobTitle: fullConversation.profile?.jobTitle || "Unknown",
            headline: fullConversation.profile?.headline || "Unknown",
            conversationHistory: fullConversation.messages.map((m) => `${m.speaker}: ${m.content}`).join("\n"),
            messageCount: fullConversation.messages.length,
            detectedAt: new Date().toISOString(),
          };
          await sendLeadWebhook(payload);
          updateStats("leadsFound", 1);
          addLog("SUCCESS", `ðŸ”¥ HOT LEAD: ${leadName} sent to webhook!`, "Bot");
        }
      } catch (e) {
        addLog("ERROR", `Lead webhook failed: ${getErrorMsg(e)}`, "System");
      }
    }

    let replyData;
    try {
      replyData = await fetchReply(replyApiKey, prompt, fullConversation.messages, leadName, myName, fullConversation.profile, replyProvider === "groq", groqModel, closeState);
      updateStats("tokensUsed", replyData.tokensUsed);
    } catch (e) {
      addLog("ERROR", `Reply Generation Failed: ${getErrorMsg(e)}`, "System");
      continue;
    }

    let finalReply = replyData.reply;
    if (replyPreviewEnabled) {
      const approval = await waitForReplyApproval(leadName, replyData.reply);
      if (!approval.approved) {
        addLog("INFO", `Reply to ${leadName} skipped by user`, "User");
        continue;
      }
      finalReply = approval.reply;
    }

    const input = await waitForElement<HTMLElement>("div.msg-form__contenteditable[role='textbox']", 6, 400);
    const sendBtn = await waitForElement<HTMLButtonElement>("button.msg-form__send-button", 6, 400);

    if (input && sendBtn) {
      const conversationMeta = { messageCount: fullConversation.messages.length, lastMessageQuestions: (fullConversation.messages[fullConversation.messages.length - 1]?.content.match(/\?/g) || []).length };
      const shouldSplit = shouldDoubleText(finalReply, conversationMeta);
      const doubleTextPattern = shouldSplit ? generateDoubleText(finalReply, conversationMeta) : null;

      if (doubleTextPattern) {
        addLog("ACTION", `Double-texting ${leadName} (${doubleTextPattern.pattern})...`, "Bot");
        await delay(calculateTypingDelay(doubleTextPattern.firstMessage));
        await setEditableText(input, doubleTextPattern.firstMessage);
        await delay(800);

        if (!sendBtn.hasAttribute("disabled")) {
          sendBtn.click();
          await delay(500);
          const betweenDelay = calculateDoubleTextDelay(doubleTextPattern.pattern);
          addLog("INFO", `Waiting ${Math.round(betweenDelay / 1000)}s before second message...`, "Bot");
          await delay(betweenDelay);
          await delay(calculateTypingDelay(doubleTextPattern.secondMessage));
          await setEditableText(input, doubleTextPattern.secondMessage);
          await delay(800);

          if (!sendBtn.hasAttribute("disabled")) {
            sendBtn.click();
            await delay(500);
            updateStats("repliesSent", 1);
            fullConversation.messages.push(
              { speaker: myName, content: doubleTextPattern.firstMessage, timestamp: Date.now() - betweenDelay, type: "sent" },
              { speaker: myName, content: doubleTextPattern.secondMessage, timestamp: Date.now(), type: "sent" }
            );
            fullConversation.metadata.lastActivity = Date.now();
            fullConversation.metadata.lastMessageFrom = "me";
            fullConversation.metadata.totalMessages += 2;
            fullConversation.metadata.lastSyncedAt = Date.now();
            await saveConversation(fullConversation);
            addLog("SUCCESS", `Double-texted ${formatProfileForDisplay(leadName, fullConversation.profile)} (${getModelDisplayName(currentModelName)})`, "Bot");
          }
        }
      } else {
        const typingDelay = calculateTypingDelay(finalReply);
        addLog("ACTION", `Typing reply to ${leadName} (waiting ${Math.round(typingDelay / 1000)}s)...`, "Bot");
        await delay(typingDelay);
        await setEditableText(input, finalReply);
        await delay(800);

        if (!sendBtn.hasAttribute("disabled")) {
          sendBtn.click();
          await delay(500);
          if ((input.textContent?.trim() || "").length === 0) {
            updateStats("repliesSent", 1);
            fullConversation.messages.push({ speaker: myName, content: finalReply, timestamp: Date.now(), type: "sent" });
            fullConversation.metadata.lastActivity = Date.now();
            fullConversation.metadata.lastMessageFrom = "me";
            fullConversation.metadata.totalMessages++;
            fullConversation.metadata.lastSyncedAt = Date.now();
            await saveConversation(fullConversation);
            addLog("SUCCESS", `Sent reply to ${formatProfileForDisplay(leadName, fullConversation.profile)} (${getModelDisplayName(currentModelName)})`, "Bot");
          } else {
            addLog("WARNING", `Message may not have sent to ${leadName}`, "System");
          }
        } else {
          addLog("ERROR", `Send button disabled for ${leadName}`, "System");
        }
      }
    } else {
      addLog("ERROR", "Could not find chat input or send button", "System");
    }

    await randomDelay(chatMin, chatMax);
  }

  addLog("INFO", "Batch finished. Sleeping...", "System");
  if (botRunning && !botPaused) {
    botLoopTimeout = window.setTimeout(() => runIteration(n), Math.floor(Math.random() * (loopMax - loopMin + 1)) + loopMin);
  }
}

// --- MESSAGE LISTENER ---
chrome.runtime.onMessage.addListener((msg: ContentCommand, _sender, sendResponse) => {
  if (msg.type === "PING_TEST") {
    sendResponse("âœ… Content script active!");
    return;
  }

  if (msg.type === "GET_STATUS") {
    sendResponse({ running: botRunning, paused: botPaused, stats, logs });
    return;
  }

  if (msg.type === "START_BOT") {
    if (!botRunning) {
      botRunning = true;
      botPaused = false;
      stats = { chatsProcessed: 0, repliesSent: 0, leadsFound: 0, startTime: Date.now(), tokensUsed: 0, currentModel: "" };
      useStrictHours = (msg as any).config?.strictHours ?? true;
      groqModel = (msg as any).config?.groqModel ?? "llama-3.3-70b-versatile";
      replyPreviewEnabled = (msg as any).config?.replyPreviewEnabled ?? false;
      blacklist = (msg as any).config?.blacklist ?? [];
      addLog("INFO", `Bot started (Strict Hours: ${useStrictHours ? "ON" : "OFF"}, Preview: ${replyPreviewEnabled ? "ON" : "OFF"})`, "User");
      runIteration((msg as any).config?.nChats ?? 10);
      sendResponse({ status: "ok" });
    } else {
      sendResponse({ status: "error", error: "Already running" });
    }
    return;
  }

  if (msg.type === "STOP_BOT") {
    botRunning = false;
    botPaused = false;
    if (botLoopTimeout !== null) clearTimeout(botLoopTimeout);
    addLog("INFO", "Bot stopped by user", "User");
    sendResponse({ status: "stopped" });
    return;
  }

  if (msg.type === "PAUSE_BOT") {
    if (botRunning && !botPaused) {
      botPaused = true;
      addLog("INFO", "Bot paused by user", "User");
      sendResponse({ status: "paused" });
    } else {
      sendResponse({ status: "error", error: "Not running or already paused" });
    }
    return;
  }

  if (msg.type === "RESUME_BOT") {
    if (botRunning && botPaused) {
      botPaused = false;
      addLog("INFO", "Bot resumed by user", "User");
      sendResponse({ status: "running" });
    } else {
      sendResponse({ status: "error", error: "Not paused" });
    }
    return;
  }

  if (msg.type === "APPROVE_REPLY") {
    if (pendingReplyResolve) {
      addLog("SUCCESS", `Reply to ${msg.leadName} approved`, "User");
      pendingReplyResolve({ approved: true, reply: msg.reply });
      pendingReplyResolve = null;
      chrome.storage.local.remove(["pendingReply"]);
    }
    sendResponse({ status: "ok" });
    return;
  }

  if (msg.type === "REJECT_REPLY") {
    if (pendingReplyResolve) {
      addLog("INFO", `Reply to ${msg.leadName} rejected`, "User");
      pendingReplyResolve({ approved: false, reply: "" });
      pendingReplyResolve = null;
      chrome.storage.local.remove(["pendingReply"]);
    }
    sendResponse({ status: "ok" });
    return;
  }

  if (msg.type === "CHECK_UNREAD") {
    if (botRunning && !botPaused) addLog("INFO", "Check unread triggered by background", "System");
    sendResponse({ status: "ok" });
    return;
  }
});

====================================================================================================
FILE: src/options/options.css
====================================================================================================

/* linkedinresponder/src/options/options.css */
@import url("https://fonts.googleapis.com/css2?family=Alata&display=swap");

:root {
  --bg1: #fbf2c4;
  --bg2: #e5c185;
  --text: #173a35;
  --muted: #6c757d;
  --accent: #008585;
  --accent-hover: #006b6b;
  --accent-2: #c7522a;
  --panel: rgba(255, 255, 255, 0.95);
  --border: rgba(23, 58, 53, 0.12);
  --radius: 12px;
  --input-bg: rgba(255, 255, 255, 0.6);
  --success: #74a892;
}

[data-theme="dark"] {
  --bg1: #1a2420;
  --bg2: #243330;
  --text: #e8efe8;
  --muted: #9aa8a2;
  --panel: rgba(30, 42, 38, 0.95);
  --border: rgba(255, 255, 255, 0.1);
  --input-bg: rgba(0, 0, 0, 0.2);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body, #options-root {
  min-height: 100vh;
  font-family: "Alata", sans-serif;
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  background: linear-gradient(145deg, var(--bg1) 0%, var(--bg2) 100%);
  background-attachment: fixed;
}

/* Shell */
.options-shell {
  max-width: 960px;
  margin: 0 auto;
  padding: 24px 20px 40px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

/* Header */
.options-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 12px;
  padding: 16px 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
}

.header-left {
  display: flex;
  align-items: center;
  gap: 14px;
}

.header-icon {
  width: 44px;
  height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, var(--accent-2), var(--accent));
  border-radius: 10px;
  font-size: 20px;
}

.header-left h1 {
  font-size: 18px;
  font-weight: 600;
  color: var(--text);
}

.header-left p {
  font-size: 12px;
  color: var(--muted);
  margin-top: 2px;
}

.header-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

/* Banners */
.banner {
  padding: 12px 16px;
  border-radius: var(--radius);
  font-size: 13px;
  display: flex;
  align-items: center;
  gap: 10px;
}

.banner.error {
  background: rgba(199, 82, 42, 0.12);
  border: 1px solid rgba(199, 82, 42, 0.25);
  color: var(--accent-2);
}

.banner.warn {
  background: rgba(229, 193, 133, 0.25);
  border: 1px solid rgba(229, 193, 133, 0.4);
  color: var(--text);
}

/* Grid */
.grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 16px;
}

@media (max-width: 720px) {
  .grid {
    grid-template-columns: 1fr;
  }
  .card.wide {
    grid-column: span 1;
  }
}

/* Cards */
.card {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.card.wide {
  grid-column: span 2;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 14px;
  font-weight: 600;
  color: var(--text);
}

.card-body {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.card-body.two-col {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 14px;
}

@media (max-width: 520px) {
  .card-body.two-col {
    grid-template-columns: 1fr;
  }
}

/* Form elements */
.field-block {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.field-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--text);
}

input,
select,
textarea {
  width: 100%;
  padding: 11px 14px;
  font-family: inherit;
  font-size: 13px;
  color: var(--text);
  background: var(--input-bg);
  border: 1px solid var(--border);
  border-radius: 10px;
  transition: border-color 0.2s, background 0.2s;
}

input:focus,
select:focus,
textarea:focus {
  outline: none;
  border-color: var(--accent);
  background: rgba(0, 133, 133, 0.06);
}

textarea {
  min-height: 90px;
  resize: vertical;
  line-height: 1.5;
}

select {
  cursor: pointer;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='%23173a35'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
  padding-right: 36px;
}

[data-theme="dark"] select {
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='%23e8efe8'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
}

/* Row helper */
.row {
  display: flex;
  gap: 10px;
  align-items: center;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 10px 16px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  border: 1px solid var(--border);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.15s ease;
}

.btn.ghost {
  background: transparent;
  color: var(--text);
}

.btn.ghost:hover {
  border-color: var(--accent);
  color: var(--accent);
}

.btn.primary {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}

.btn.primary:hover {
  background: var(--accent-hover);
  border-color: var(--accent-hover);
}

.btn.primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn.primary.success {
  background: var(--success);
  border-color: var(--success);
}

.btn.danger {
  background: transparent;
  border-color: var(--accent-2);
  color: var(--accent-2);
}

.btn.danger:hover {
  background: var(--accent-2);
  color: #fff;
}

/* Status dot */
.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* Pill */
.pill {
  display: inline-flex;
  align-items: center;
  padding: 4px 10px;
  font-size: 11px;
  font-weight: 500;
  background: rgba(0, 133, 133, 0.1);
  color: var(--accent);
  border: 1px solid rgba(0, 133, 133, 0.2);
  border-radius: 999px;
}

.pill.pill-warn {
  background: rgba(199, 82, 42, 0.1);
  color: var(--accent-2);
  border-color: rgba(199, 82, 42, 0.2);
}

/* Quick buttons */
.quick-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 4px;
}

.quick-row button {
  flex: 1;
  min-width: 80px;
  padding: 8px 12px;
  font-size: 12px;
  background: var(--input-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  cursor: pointer;
  transition: all 0.15s ease;
}

.quick-row button:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* Chip row */
.chip-row {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 6px;
}

.chip-label {
  font-size: 11px;
  color: var(--muted);
}

.chip {
  padding: 5px 12px;
  font-size: 11px;
  font-family: monospace;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  transition: background 0.15s ease;
}

.chip:hover {
  background: var(--accent-hover);
}

/* Muted / Help text */
.muted {
  font-size: 12px;
  color: var(--muted);
}

.text-warn {
  color: var(--accent-2);
}

/* Footer */
.options-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 12px;
  padding: 14px 20px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  font-size: 13px;
  color: var(--muted);
}

.footer-actions {
  display: flex;
  gap: 10px;
}

.unsaved-dot {
  color: var(--accent-2);
  font-size: 16px;
}

/* Scrollbar */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--accent);
}

.card-body.three-col {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 14px;
}

@media (max-width: 720px) {
  .card-body.three-col {
    grid-template-columns: 1fr;
  }
}

.webhook-preview {
  margin-top: 12px;
  padding: 12px;
  background: var(--input-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
}

.code-block {
  margin: 0;
  padding: 12px;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  line-height: 1.5;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 6px;
  overflow-x: auto;
  white-space: pre;
  color: var(--text);
}

[data-theme="dark"] .code-block {
  background: rgba(255, 255, 255, 0.05);
}

====================================================================================================
FILE: src/options/options.tsx
====================================================================================================

// linkedinresponder/src/options/options.tsx
import React, { useEffect, useRef, useState } from "react";
import { createRoot } from "react-dom/client";
import "./options.css";
import { DEFAULT_SETTINGS, getBotSettings, setBotSettings, BotSettings, AIProvider } from "../shared/settings";

type SaveState = "idle" | "saving" | "saved" | "error";
type ApiTestStatus = "idle" | "testing" | "success" | "error";

interface ApiKeyStatus { openai: ApiTestStatus; groq: ApiTestStatus; }
interface ApiKeyMessage { openai: string; groq: string; }

const Options = () => {
  const [settings, setSettings] = useState<BotSettings>(DEFAULT_SETTINGS);
  const [originalSettings, setOriginalSettings] = useState<BotSettings>(DEFAULT_SETTINGS);
  const [saveState, setSaveState] = useState<SaveState>("idle");
  const [error, setError] = useState<string | null>(null);
  const [darkMode, setDarkMode] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  const [apiStatus, setApiStatus] = useState<ApiKeyStatus>({ openai: "idle", groq: "idle" });
  const [apiMessage, setApiMessage] = useState<ApiKeyMessage>({ openai: "", groq: "" });

  const fileInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    (async () => {
      try {
        const s = await getBotSettings();
        setSettings(s);
        setOriginalSettings(s);
      } catch {
        setError("Failed to load settings");
      }
    })();
    chrome.storage.local.get(["darkMode"], (data) => {
      if (data.darkMode !== undefined) setDarkMode(data.darkMode);
    });
  }, []);

  useEffect(() => {
    setHasUnsavedChanges(JSON.stringify(settings) !== JSON.stringify(originalSettings));
  }, [settings, originalSettings]);

  useEffect(() => {
    document.documentElement.setAttribute("data-theme", darkMode ? "dark" : "light");
    chrome.storage.local.set({ darkMode });
  }, [darkMode]);

  const updateSetting = <K extends keyof BotSettings>(key: K, value: BotSettings[K]) =>
    setSettings((prev) => ({ ...prev, [key]: value }));

  const handleSave = async () => {
    setError(null);
    setSaveState("saving");

    if (settings.endHour <= settings.startHour) {
      setSaveState("error");
      setError("End hour must be after start hour");
      return;
    }
    if (!settings.openaiApiKey.trim()) {
      setSaveState("error");
      setError("OpenAI API key is required");
      return;
    }
    if (!settings.groqApiKey.trim()) {
      setSaveState("error");
      setError("Groq API key is required");
      return;
    }

    try {
      await setBotSettings(settings);
      setOriginalSettings(settings);
      setSaveState("saved");
      setHasUnsavedChanges(false);
      setTimeout(() => setSaveState("idle"), 1800);
    } catch {
      setSaveState("error");
      setError("Failed to save settings");
    }
  };

  const handleReset = () => {
    if (!confirm("Reset all settings to defaults?\n\nThis cannot be undone.")) return;
    setSettings(DEFAULT_SETTINGS);
  };

  const handleImport = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target?.result as string);
        if (data.settings) {
          setSettings({ ...DEFAULT_SETTINGS, ...data.settings });
          setError(null);
        } else {
          setError("Invalid settings file");
        }
      } catch {
        setError("Failed to parse settings file");
      }
    };
    reader.readAsText(file);
    e.target.value = "";
  };

  const handleExport = () => {
    const data = { settings, exportedAt: new Date().toISOString(), version: "2.7.0" };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `linkedin-autoresponder-settings-${new Date().toISOString().slice(0, 10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const testApiKey = async (type: "openai" | "groq") => {
    const keyMap = {
      openai: settings.openaiApiKey,
      groq: settings.groqApiKey,
    };

    const key = keyMap[type];

    setApiStatus((s) => ({ ...s, [type]: "testing" }));
    setApiMessage((m) => ({ ...m, [type]: "" }));

    if (!key?.trim()) {
      setApiStatus((s) => ({ ...s, [type]: "error" }));
      setApiMessage((m) => ({ ...m, [type]: "Key is empty" }));
      return;
    }

    try {
      const response = await chrome.runtime.sendMessage({
        type: "TEST_API_KEY",
        provider: type,
        key,
      });

      if (response?.success) {
        setApiStatus((s) => ({ ...s, [type]: "success" }));
        setApiMessage((m) => ({ ...m, [type]: response.message }));
      } else {
        setApiStatus((s) => ({ ...s, [type]: "error" }));
        setApiMessage((m) => ({ ...m, [type]: response?.message || "Test failed" }));
      }
    } catch (err: any) {
      setApiStatus((s) => ({ ...s, [type]: "error" }));
      setApiMessage((m) => ({ ...m, [type]: err?.message || "Could not reach background script" }));
    }
  };

  const formatHour = (hour: number) => {
    const period = hour >= 12 ? "PM" : "AM";
    const h = hour % 12 || 12;
    return `${h}:00 ${period}`;
  };

  const timeBadge =
    settings.endHour > settings.startHour
      ? `${formatHour(settings.startHour)} â€“ ${formatHour(settings.endHour)}`
      : "Invalid";

  // Helper to set all providers at once
  const setAllProviders = (provider: AIProvider) => {
    updateSetting("replyProvider", provider);
    updateSetting("decisionProvider", provider);
    updateSetting("leadDetectionProvider", provider);
  };

  return (
    <div className="options-shell">
      <header className="options-header">
        <div className="header-left">
          <div className="header-icon">âš™ï¸</div>
          <div>
            <h1>Settings</h1>
            <p>LinkedIn Autoresponder v2.7.0</p>
          </div>
        </div>
        <div className="header-actions">
          <button className="btn ghost" onClick={() => fileInputRef.current?.click()}>Import</button>
          <input ref={fileInputRef} type="file" accept=".json" onChange={handleImport} style={{ display: "none" }} />
          <button className="btn ghost" onClick={handleExport}>Export</button>
          <button className="btn ghost" onClick={handleReset}>Reset</button>
          <button className="btn ghost" onClick={() => setDarkMode(!darkMode)}>{darkMode ? "â˜€ï¸" : "ðŸŒ™"}</button>
        </div>
      </header>

      {error && <div className="banner error">âš ï¸ {error}</div>}
      {hasUnsavedChanges && !error && <div className="banner warn">You have unsaved changes</div>}

      <div className="grid">
        {/* API Keys */}
        <section className="card wide">
          <div className="card-header">API Keys</div>
          <div className="card-body two-col">
            <ApiKeyField
              label="OpenAI API Key"
              value={settings.openaiApiKey}
              onChange={(v) => updateSetting("openaiApiKey", v)}
              placeholder="sk-..."
              status={apiStatus.openai}
              message={apiMessage.openai}
              onTest={() => testApiKey("openai")}
            />
            <ApiKeyField
              label="Groq API Key"
              value={settings.groqApiKey}
              onChange={(v) => updateSetting("groqApiKey", v)}
              placeholder="gsk_..."
              status={apiStatus.groq}
              message={apiMessage.groq}
              onTest={() => testApiKey("groq")}
            />
          </div>
        </section>

        {/* AI Provider Selection */}
        <section className="card wide">
          <div className="card-header">AI Provider Selection</div>
          <div className="card-body three-col">
            <ProviderSelect
              label="Reply Generation"
              description="Generates chat responses"
              value={settings.replyProvider}
              onChange={(v) => updateSetting("replyProvider", v)}
            />
            <ProviderSelect
              label="Reply Decision"
              description="Decides if bot should reply"
              value={settings.decisionProvider}
              onChange={(v) => updateSetting("decisionProvider", v)}
            />
            <ProviderSelect
              label="Lead Detection"
              description="Identifies qualified leads"
              value={settings.leadDetectionProvider}
              onChange={(v) => updateSetting("leadDetectionProvider", v)}
            />
          </div>
          <div className="quick-row">
            <button onClick={() => setAllProviders("groq")}>All Groq</button>
            <button onClick={() => setAllProviders("openai")}>All OpenAI</button>
            <button onClick={() => {
              updateSetting("replyProvider", "groq");
              updateSetting("decisionProvider", "groq");
              updateSetting("leadDetectionProvider", "openai");
            }}>Recommended</button>
          </div>
          <p className="muted" style={{ marginTop: "8px" }}>
            ðŸ’¡ <strong>Recommended:</strong> Groq for replies & decisions (fast, cheap), OpenAI for lead detection (accurate).
          </p>
        </section>

        {/* Lead Webhook */}
        <section className="card wide">
          <div className="card-header">Lead Notifications</div>
          <div className="card-body">
            <div className="field-block">
              <label className="field-label">Zapier Webhook URL</label>
              <input
                type="url"
                value={settings.webhookUrl}
                onChange={(e) => updateSetting("webhookUrl", e.target.value)}
                placeholder="https://hooks.zapier.com/hooks/catch/..."
              />
              <span className="muted">When a lead is detected, JSON data will be sent to this webhook.</span>
            </div>
            {settings.webhookUrl && (
              <div className="webhook-preview">
                <p className="field-label" style={{ marginBottom: "8px" }}>Payload Preview:</p>
                <pre className="code-block">{`{
  "leadName": "John Smith",
  "profileUrl": "https://linkedin.com/in/...",
  "company": "Acme Corp",
  "jobTitle": "VP of Sales",
  "headline": "VP of Sales at Acme Corp",
  "conversationHistory": "...",
  "messageCount": 12,
  "detectedAt": "2025-01-03T19:42:00Z"
}`}</pre>
              </div>
            )}
          </div>
        </section>

        {/* Working Hours */}
        <section className="card">
          <div className="card-header">
            <span>Working Hours</span>
            <span className={`pill ${settings.endHour <= settings.startHour ? "pill-warn" : ""}`}>{timeBadge}</span>
          </div>
          <div className="card-body two-col">
            <div className="field-block">
              <label className="field-label">Start</label>
              <select value={settings.startHour} onChange={(e) => updateSetting("startHour", Number(e.target.value))}>
                {Array.from({ length: 24 }, (_, i) => (
                  <option key={i} value={i}>{formatHour(i)}</option>
                ))}
              </select>
            </div>
            <div className="field-block">
              <label className="field-label">End</label>
              <select value={settings.endHour} onChange={(e) => updateSetting("endHour", Number(e.target.value))}>
                {Array.from({ length: 24 }, (_, i) => (
                  <option key={i} value={i}>{formatHour(i)}</option>
                ))}
              </select>
            </div>
          </div>
          {settings.endHour <= settings.startHour && (
            <p className="muted text-warn">End time must be later than start time.</p>
          )}
          <div className="quick-row">
            <button onClick={() => { updateSetting("startHour", 9); updateSetting("endHour", 17); }}>Business</button>
            <button onClick={() => { updateSetting("startHour", 8); updateSetting("endHour", 20); }}>Extended</button>
            <button onClick={() => { updateSetting("startHour", 0); updateSetting("endHour", 23); }}>24/7</button>
          </div>
        </section>

        {/* Timing */}
        <section className="card">
          <div className="card-header">Timing & Delays</div>
          <div className="card-body two-col">
            <NumberField label="Chat Min (sec)" value={settings.chatMinDelay / 1000} onChange={(v) => updateSetting("chatMinDelay", v * 1000)} min={0.25} max={60} step={0.25} />
            <NumberField label="Chat Max (sec)" value={settings.chatMaxDelay / 1000} onChange={(v) => updateSetting("chatMaxDelay", v * 1000)} min={0.25} max={120} step={0.25} />
            <NumberField label="Loop Min (sec)" value={settings.loopMinDelay / 1000} onChange={(v) => updateSetting("loopMinDelay", v * 1000)} min={1} max={600} step={1} />
            <NumberField label="Loop Max (sec)" value={settings.loopMaxDelay / 1000} onChange={(v) => updateSetting("loopMaxDelay", v * 1000)} min={1} max={600} step={1} />
          </div>
          <div className="quick-row">
            <button onClick={() => { updateSetting("chatMinDelay", 1000); updateSetting("chatMaxDelay", 2000); updateSetting("loopMinDelay", 5000); updateSetting("loopMaxDelay", 10000); }}>Fast</button>
            <button onClick={() => { updateSetting("chatMinDelay", 2000); updateSetting("chatMaxDelay", 5000); updateSetting("loopMinDelay", 10000); updateSetting("loopMaxDelay", 30000); }}>Normal</button>
            <button onClick={() => { updateSetting("chatMinDelay", 3000); updateSetting("chatMaxDelay", 8000); updateSetting("loopMinDelay", 30000); updateSetting("loopMaxDelay", 60000); }}>Human-like</button>
          </div>
        </section>

        {/* Prompts */}
        <section className="card wide">
          <div className="card-header">AI Prompts</div>
          <div className="card-body two-col">
            <div className="field-block">
              <label className="field-label">Reply Prompt</label>
              <textarea rows={5} value={settings.replyPrompt} onChange={(e) => updateSetting("replyPrompt", e.target.value)} />
              <div className="chip-row">
                <span className="chip-label">Variables:</span>
                <button className="chip" onClick={() => updateSetting("replyPrompt", settings.replyPrompt + "{user_name}")}>{`{user_name}`}</button>
                <button className="chip" onClick={() => updateSetting("replyPrompt", settings.replyPrompt + "{extracted_text}")}>{`{extracted_text}`}</button>
              </div>
            </div>
            <div className="field-block">
              <label className="field-label">Lead Detection Prompt</label>
              <textarea rows={3} value={settings.leadPrompt} onChange={(e) => updateSetting("leadPrompt", e.target.value)} />
            </div>
          </div>
          <div className="quick-row">
            <button onClick={() => updateSetting("replyPrompt", "You are {user_name}'s professional assistant. Reply briefly and helpfully to: {extracted_text}")}>Professional</button>
            <button onClick={() => updateSetting("replyPrompt", "You are {user_name}. Reply casually and friendly to: {extracted_text}")}>Casual</button>
            <button onClick={() => updateSetting("replyPrompt", "You are {user_name}, a sales professional. Reply with interest and ask qualifying questions to: {extracted_text}")}>Sales</button>
          </div>
        </section>
      </div>

      <footer className="options-footer">
        <div style={{ display: "flex", alignItems: "center", gap: "8px" }}>
          {hasUnsavedChanges && <span className="unsaved-dot">â—</span>}
          <span>{hasUnsavedChanges ? "Unsaved changes" : "All changes saved"}</span>
        </div>
        <div className="footer-actions">
          <button className="btn ghost" onClick={() => setSettings(originalSettings)} disabled={!hasUnsavedChanges}>Cancel</button>
          <button className={`btn primary ${saveState === "saved" ? "success" : ""}`} onClick={handleSave} disabled={saveState === "saving" || !hasUnsavedChanges}>
            {saveState === "saving" ? "Saving..." : saveState === "saved" ? "âœ“ Saved" : "Save Settings"}
          </button>
        </div>
      </footer>
    </div>
  );
};

function ApiKeyField(props: { label: string; value: string; onChange: (v: string) => void; placeholder: string; status: ApiTestStatus; message: string; onTest: () => void }) {
  return (
    <div className="field-block">
      <label className="field-label">{props.label}</label>
      <div className="row">
        <input type="password" value={props.value} onChange={(e) => props.onChange(e.target.value)} placeholder={props.placeholder} style={{ flex: 1 }} />
        <button className="btn ghost" onClick={props.onTest} disabled={!props.value || props.status === "testing"} style={{ whiteSpace: "nowrap" }}>
          {props.status === "testing" ? "..." : "Test"}
        </button>
        <StatusDot status={props.status} />
      </div>
      {props.message && <span className={`muted ${props.status === "error" ? "text-warn" : ""}`}>{props.message}</span>}
    </div>
  );
}

function ProviderSelect(props: { label: string; description: string; value: AIProvider; onChange: (v: AIProvider) => void }) {
  return (
    <div className="field-block">
      <label className="field-label">{props.label}</label>
      <select value={props.value} onChange={(e) => props.onChange(e.target.value as AIProvider)}>
        <option value="groq">Groq (Fast)</option>
        <option value="openai">OpenAI (Accurate)</option>
      </select>
      <span className="muted">{props.description}</span>
    </div>
  );
}

function NumberField(props: { label: string; value: number; onChange: (v: number) => void; min: number; max: number; step: number }) {
  return (
    <div className="field-block">
      <label className="field-label">{props.label}</label>
      <input type="number" value={props.value} min={props.min} max={props.max} step={props.step} onChange={(e) => props.onChange(Number(e.target.value))} />
    </div>
  );
}

function StatusDot({ status }: { status: ApiTestStatus }) {
  const color = status === "success" ? "#74a892" : status === "error" ? "#c7522a" : status === "testing" ? "#e5c185" : "#adb5bd";
  return <span className="status-dot" style={{ background: color }} />;
}

const root = createRoot(document.getElementById("options-root")!);
root.render(<Options />);

====================================================================================================
FILE: src/popup/popup.css
====================================================================================================

/* linkedinresponder/src/popup/popup.css */
@import url("https://fonts.googleapis.com/css2?family=Alata&display=swap");
@import "tailwindcss";

:root {
  --popup-width: 460px;
  --popup-height: 640px;

  --bg1: #fbf2c4;
  --bg2: #e5c185;

  --text: #173a35;
  --muted: #6c757d;

  --accent: #008585;
  --accent-2: #c7522a;

  --panel: rgba(255, 255, 255, 0.92);
  --border: rgba(0, 0, 0, 0.08);

  --radius: 14px;
  --terminal-min-height: 180px;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body,
#popup-root {
  width: var(--popup-width);
  height: var(--popup-height);
  overflow: hidden;
  font-family: "Alata", sans-serif;
  color: var(--text);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

body {
  background: linear-gradient(135deg, var(--bg1) 0%, var(--bg2) 100%);
}

#popup-root {
  display: flex;
  flex-direction: column;
}

.popup-shell {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding: 12px;
  gap: 10px;
}

.popup-card {
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
}

.log-container {
  overflow-y: auto;
  overscroll-behavior: contain;
  scrollbar-gutter: stable;
  scroll-behavior: smooth;
  min-height: var(--terminal-min-height);
}

.log-container::-webkit-scrollbar {
  width: 6px;
}

.log-container::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.08);
  border-radius: 10px;
}

.log-container::-webkit-scrollbar-thumb {
  background: #74a892;
  border-radius: 10px;
}

.log-container::-webkit-scrollbar-thumb:hover {
  background: var(--accent);
}

button {
  min-height: 36px;
  border-radius: 10px;
}

button:focus,
button:focus-visible,
input:focus,
textarea:focus,
select:focus {
  outline: 2px solid rgba(0, 133, 133, 0.35);
  outline-offset: 2px;
}

input,
select,
textarea {
  font-size: 13px;
}

.noselect {
  user-select: none;
}

.terminal-wrapper {
  flex: 1;
  min-height: var(--terminal-min-height);
  display: flex;
  flex-direction: column;
}

/* Material Symbols styling */
.material-symbols-outlined {
  font-variation-settings:
    'FILL' 0,
    'wght' 400,
    'GRAD' 0,
    'opsz' 20;
}

====================================================================================================
FILE: src/popup/popup.tsx
====================================================================================================

// linkedinresponder/src/popup/popup.tsx

import React, { useEffect, useMemo, useRef, useState } from "react";
import { createRoot } from "react-dom/client";
import { BotCommand, BotStatus, BotLogEntry, BotStats } from "../shared/types";
import "./popup.css";

const STATUS_POLL_MS = 1000;
const STORAGE_FALLBACK_POLL_MS = 15_000;
const AUTO_SCROLL_THRESHOLD_PX = 60;

interface PendingReply {
  leadName: string;
  reply: string;
  timestamp: number;
}

const Popup = () => {
  const [running, setRunning] = useState(false);
  const [paused, setPaused] = useState(false);
  const [stats, setStats] = useState<BotStats>({
    chatsProcessed: 0,
    repliesSent: 0,
    leadsFound: 0,
    startTime: null,
    tokensUsed: 0,
    currentModel: "",
  });
  const [logs, setLogs] = useState<BotLogEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const [showSummary, setShowSummary] = useState(false);
  const [sessionSummary, setSessionSummary] = useState<any>(null);
  const [copied, setCopied] = useState(false);

  const [storageStats, setStorageStats] = useState({ conversationCount: 0, totalMessages: 0 });

  const [nChats, setNChats] = useState(10);
  const [model, setModel] = useState("gpt-4o-mini");
  const [useGroq, setUseGroq] = useState(false);
  const [groqModel, setGroqModel] = useState("llama-3.3-70b-versatile");
  const [strictHours, setStrictHours] = useState(true);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);

  const [replyPreviewEnabled, setReplyPreviewEnabled] = useState(false);
  const [pendingReply, setPendingReply] = useState<PendingReply | null>(null);
  const [editedReply, setEditedReply] = useState("");

  const [tick, setTick] = useState(0);

  const logContainerRef = useRef<HTMLDivElement | null>(null);
  const shouldAutoScrollRef = useRef(true);
  const statusIntervalRef = useRef<number | null>(null);
  const storageFallbackIntervalRef = useRef<number | null>(null);

  const isMessagingUrl = (url?: string) =>
    !!url && /https:\/\/(www\.)?linkedin\.com\/messaging/i.test(url);

  const sendToContent = async (msg: BotCommand | any): Promise<any> => {
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    const tab = tabs[0];
    if (!tab?.id || !isMessagingUrl(tab.url)) {
      setErrorMsg("Open LinkedIn Messaging and try again");
      return null;
    }

    return new Promise((resolve) => {
      chrome.tabs.sendMessage(tab.id!, msg, (response) => {
        if (chrome.runtime.lastError) {
          setErrorMsg("Content script not detected. Refresh LinkedIn Messaging.");
          resolve(null);
        } else {
          resolve(response);
        }
      });
    });
  };

  const loadStorageStats = () => {
    chrome.storage.local.get(["conversation_histories"], (result) => {
      const histories = result.conversation_histories || {};
      const count = Object.keys(histories).length;
      const totalMessages = Object.values(histories).reduce(
        (sum: number, convo: any) => sum + (convo.messages?.length || 0),
        0
      );
      setStorageStats({ conversationCount: count, totalMessages });
    });
  };

  useEffect(() => {
    chrome.storage.local.get(
      ["savedUseGroq", "savedGroqModel", "savedStrictHours", "savedModel", "replyPreviewEnabled"],
      (data) => {
        if (data.savedUseGroq !== undefined) setUseGroq(data.savedUseGroq);
        if (data.savedGroqModel) setGroqModel(data.savedGroqModel);
        if (data.savedStrictHours !== undefined) setStrictHours(data.savedStrictHours);
        if (data.savedModel) setModel(data.savedModel);
        if (data.replyPreviewEnabled !== undefined) setReplyPreviewEnabled(data.replyPreviewEnabled);
      }
    );

    const onStorageChanged: Parameters<typeof chrome.storage.onChanged.addListener>[0] = (changes, areaName) => {
      if (areaName !== "local") return;
      if (changes.conversation_histories) {
        const newVal = changes.conversation_histories.newValue || {};
        const count = Object.keys(newVal).length;
        const totalMessages = Object.values(newVal).reduce(
          (sum: number, convo: any) => sum + (convo.messages?.length || 0),
          0
        );
        setStorageStats({ conversationCount: count, totalMessages });
      }
      if (changes.pendingReply) {
        const pending = changes.pendingReply.newValue;
        if (pending && replyPreviewEnabled) {
          setPendingReply(pending);
          setEditedReply(pending.reply);
        }
      }
    };

    chrome.storage.onChanged.addListener(onStorageChanged);

    const syncState = async () => {
      try {
        const status: BotStatus = await sendToContent({ type: "GET_STATUS" });
        if (status) {
          setRunning(status.running);
          setStats(status.stats);

          setLogs((prevLogs) => {
            if (prevLogs.length !== status.logs.length) {
              return status.logs;
            }
            if (prevLogs.length > 0 && status.logs.length > 0) {
              const prevLatest = prevLogs[0];
              const newLatest = status.logs[0];
              if (prevLatest.time !== newLatest.time || prevLatest.message !== newLatest.message) {
                return status.logs;
              }
            }
            return prevLogs;
          });

          setErrorMsg(null);
        } else {
          setErrorMsg("Navigate to LinkedIn Messaging");
        }
      } catch {
        setErrorMsg("Connect to LinkedIn Messaging");
      } finally {
        setLoading(false);
      }
    };

    syncState();
    loadStorageStats();

    statusIntervalRef.current = window.setInterval(syncState, STATUS_POLL_MS);
    storageFallbackIntervalRef.current = window.setInterval(loadStorageStats, STORAGE_FALLBACK_POLL_MS);

    const tickInterval = window.setInterval(() => {
      setTick((t) => t + 1);
    }, 1000);

    return () => {
      if (statusIntervalRef.current !== null) window.clearInterval(statusIntervalRef.current);
      if (storageFallbackIntervalRef.current !== null) window.clearInterval(storageFallbackIntervalRef.current);
      window.clearInterval(tickInterval);
      chrome.storage.onChanged.removeListener(onStorageChanged);
    };
  }, [replyPreviewEnabled]);

  useEffect(() => {
    const el = logContainerRef.current;
    if (!el) return;

    const onScroll = () => {
      const distanceFromBottom = el.scrollHeight - el.scrollTop - el.clientHeight;
      shouldAutoScrollRef.current = distanceFromBottom < AUTO_SCROLL_THRESHOLD_PX;
    };

    const onMouseDown = () => {
      const distanceFromBottom = el.scrollHeight - el.scrollTop - el.clientHeight;
      if (distanceFromBottom > AUTO_SCROLL_THRESHOLD_PX) {
        shouldAutoScrollRef.current = false;
      }
    };

    el.addEventListener("scroll", onScroll, { passive: true });
    el.addEventListener("mousedown", onMouseDown, { passive: true });

    return () => {
      el.removeEventListener("scroll", onScroll);
      el.removeEventListener("mousedown", onMouseDown);
    };
  }, []);

  useEffect(() => {
    const el = logContainerRef.current;
    if (!el) return;
    if (!shouldAutoScrollRef.current) return;

    requestAnimationFrame(() => {
      if (shouldAutoScrollRef.current) {
        el.scrollTop = el.scrollHeight;
      }
    });
  }, [logs]);

  const handleUseGroqChange = (value: boolean) => {
    setUseGroq(value);
    chrome.storage.local.set({ savedUseGroq: value });
  };

  const handleGroqModelChange = (value: string) => {
    setGroqModel(value);
    chrome.storage.local.set({ savedGroqModel: value });
  };

  const handleStrictHoursChange = (value: boolean) => {
    setStrictHours(value);
    chrome.storage.local.set({ savedStrictHours: value });
  };

  const handleModelChange = (value: string) => {
    setModel(value);
    chrome.storage.local.set({ savedModel: value });
  };

  const handleReplyPreviewChange = (value: boolean) => {
    setReplyPreviewEnabled(value);
    chrome.storage.local.set({ replyPreviewEnabled: value });
  };

  const handleStart = async () => {
    setLoading(true);
    try {
      const res = await sendToContent({
        type: "START_BOT",
        config: { nChats, model, useGroq, groqModel, strictHours, replyPreviewEnabled },
      });
      if (res && res.status === "ok") {
        setRunning(true);
        setPaused(false);
        setErrorMsg(null);
      } else if (!res) {
        // errorMsg already set in sendToContent
      } else {
        setErrorMsg(res.error || "Unable to start");
      }
    } finally {
      setLoading(false);
    }
  };

  const handlePause = async () => {
    await sendToContent({ type: "PAUSE_BOT" });
    setPaused(true);
  };

  const handleResume = async () => {
    await sendToContent({ type: "RESUME_BOT" });
    setPaused(false);
  };

  const handleStop = async () => {
    setLoading(true);
    await sendToContent({ type: "STOP_BOT" });

    const duration = stats.startTime ? Date.now() - stats.startTime : 0;
    const durationMins = Math.floor(duration / 60000);
    const durationSecs = Math.floor((duration % 60000) / 1000);

    setSessionSummary({
      duration: `${durationMins}m ${durationSecs}s`,
      processed: stats.chatsProcessed,
      replied: stats.repliesSent,
      skipped: stats.chatsProcessed - stats.repliesSent,
      leads: stats.leadsFound,
      tokens: stats.tokensUsed,
      model: stats.currentModel || (useGroq ? groqModel : model),
    });

    setRunning(false);
    setPaused(false);
    setLoading(false);
    setShowSummary(true);
  };

  const handleApproveReply = async () => {
    if (!pendingReply) return;
    await sendToContent({
      type: "APPROVE_REPLY",
      reply: editedReply,
      leadName: pendingReply.leadName,
    });
    setPendingReply(null);
    setEditedReply("");
    chrome.storage.local.remove(["pendingReply"]);
  };

  const handleRejectReply = async () => {
    if (!pendingReply) return;
    await sendToContent({
      type: "REJECT_REPLY",
      leadName: pendingReply.leadName,
    });
    setPendingReply(null);
    setEditedReply("");
    chrome.storage.local.remove(["pendingReply"]);
  };

  const handleExportConversations = () => {
    chrome.storage.local.get(["conversation_histories"], (result) => {
      const data = result.conversation_histories || {};
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `linkedin-conversations-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });
  };

  const handleCopyLogs = () => {
    const logText = logs
      .map((log) => {
        const time = new Date(log.time).toLocaleTimeString([], {
          hour12: false,
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });
        return `[${time}] ${log.actor}: ${log.message}`;
      })
      .join("\n");

    navigator.clipboard
      .writeText(logText)
      .then(() => {
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
      })
      .catch(() => {
        setErrorMsg("Clipboard copy failed");
        setTimeout(() => setErrorMsg(null), 2500);
      });
  };

  const handleClearStorage = () => {
    if (!confirm(`Clear ${storageStats.conversationCount} conversation histories?\n\nThis cannot be undone.`)) return;
    chrome.storage.local.set({ conversation_histories: {} }, () => {
      setStorageStats({ conversationCount: 0, totalMessages: 0 });
    });
  };

  const openOptionsPage = () => {
    if (chrome.runtime.openOptionsPage) chrome.runtime.openOptionsPage();
    else window.open(chrome.runtime.getURL("options.html"));
  };

  const uptime = useMemo(() => {
    if (!stats.startTime) return "â€”";
    const secs = Math.max(0, Math.floor((Date.now() - stats.startTime) / 1000));
    const mm = String(Math.floor(secs / 60)).padStart(2, "0");
    const ss = String(secs % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }, [stats.startTime, tick]);

  const getTokenLimit = () => {
    if (!useGroq) return 0;
    if (groqModel === "openai/gpt-oss-120b") return 200000;
    if (groqModel.includes("kimi")) return 300000;
    if (groqModel.includes("scout") || groqModel.includes("maverick") || groqModel.includes("qwen")) return 500000;
    return 100000;
  };

  const tokenLimit = getTokenLimit();
  const tokenPercent = tokenLimit > 0 ? Math.min(100, Math.round((stats.tokensUsed / tokenLimit) * 100)) : 0;

  if (loading) {
    return (
      <div style={{ display: "flex", alignItems: "center", justifyContent: "center", height: "100%" }}>
        <div style={{ fontSize: "14px", color: "#173a35" }}>Loading...</div>
      </div>
    );
  }

  return (
    <div style={{ display: "flex", flexDirection: "column", height: "100%", background: "linear-gradient(135deg, #fbf2c4, #e5c185)" }}>
      
      {/* REPLY PREVIEW MODAL */}
      {pendingReply && (
        <div
          style={{
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: "rgba(0,0,0,0.6)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 9999,
          }}
        >
          <div
            style={{
              background: "white",
              borderRadius: "12px",
              padding: "16px",
              maxWidth: "380px",
              width: "95%",
              boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
            }}
          >
            <h2 style={{ fontSize: "14px", fontWeight: "600", color: "#173a35", marginBottom: "8px" }}>
              ðŸ“ Review Reply to {pendingReply.leadName}
            </h2>
            <textarea
              value={editedReply}
              onChange={(e) => setEditedReply(e.target.value)}
              style={{
                width: "100%",
                minHeight: "100px",
                padding: "10px",
                border: "1px solid #dee2e6",
                borderRadius: "6px",
                fontSize: "12px",
                fontFamily: "inherit",
                resize: "vertical",
              }}
            />
            <div style={{ display: "flex", gap: "8px", marginTop: "12px" }}>
              <button
                onClick={handleRejectReply}
                style={{
                  flex: 1,
                  padding: "10px",
                  background: "#f8f9fa",
                  border: "1px solid #dee2e6",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "500",
                  color: "#c7522a",
                  cursor: "pointer",
                }}
              >
                âœ• Skip
              </button>
              <button
                onClick={handleApproveReply}
                style={{
                  flex: 1,
                  padding: "10px",
                  background: "#008585",
                  border: "none",
                  borderRadius: "6px",
                  fontSize: "12px",
                  fontWeight: "500",
                  color: "white",
                  cursor: "pointer",
                }}
              >
                âœ“ Send
              </button>
            </div>
          </div>
        </div>
      )}

      {/* SESSION SUMMARY MODAL */}
      {showSummary && sessionSummary && (
        <div
          style={{
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: "rgba(0,0,0,0.5)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 9999,
          }}
          onClick={() => setShowSummary(false)}
        >
          <div
            style={{
              background: "white",
              borderRadius: "12px",
              padding: "20px",
              maxWidth: "320px",
              width: "90%",
              boxShadow: "0 4px 20px rgba(0,0,0,0.3)",
            }}
            onClick={(e) => e.stopPropagation()}
          >
            <h2 style={{ fontSize: "16px", fontWeight: "600", color: "#173a35", marginBottom: "16px", textAlign: "center" }}>
              âœ… Session Complete
            </h2>

            <div style={{ display: "grid", gap: "10px" }}>
              <SummaryRow label="Duration" value={sessionSummary.duration} valueColor="#173a35" />
              <SummaryRow label="Processed" value={sessionSummary.processed} valueColor="#008585" />
              <SummaryRow label="Replied" value={sessionSummary.replied} valueColor="#74a892" />
              <SummaryRow label="Skipped" value={sessionSummary.skipped} valueColor="#6c757d" />
              <SummaryRow label="Leads Found" value={sessionSummary.leads} valueColor="#c7522a" />
              <SummaryRow label="Tokens Used" value={sessionSummary.tokens.toLocaleString()} valueColor="#173a35" />
              <SummaryRow label="Model" value={sessionSummary.model} valueColor="#173a35" small />
            </div>

            <button
              onClick={() => setShowSummary(false)}
              style={{
                width: "100%",
                marginTop: "16px",
                padding: "10px",
                background: "#008585",
                color: "white",
                border: "none",
                borderRadius: "6px",
                fontSize: "12px",
                fontWeight: "500",
                cursor: "pointer",
              }}
            >
              Close
            </button>
          </div>
        </div>
      )}

      {/* HEADER */}
      <div
        style={{
          background: "linear-gradient(135deg, #c7522a, #008585)",
          color: "white",
          padding: "12px 14px",
        }}
      >
        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <div style={{ display: "flex", alignItems: "center", gap: "10px" }}>
            <div
              style={{
                width: "32px",
                height: "32px",
                background: "rgba(255,255,255,0.2)",
                borderRadius: "8px",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                border: "1px solid rgba(255,255,255,0.3)",
              }}
            >
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" stroke="white" strokeWidth="2" />
              </svg>
            </div>
            <div>
              <div style={{ fontSize: "14px", fontWeight: "600" }}>LinkedIn Autoresponder</div>
              <div style={{ fontSize: "9px", opacity: 0.9 }}>Human-like AI agent</div>
            </div>
          </div>

          <div style={{ textAlign: "right" }}>
            <div
              style={{
                padding: "2px 8px",
                borderRadius: "20px",
                fontSize: "9px",
                fontWeight: "500",
                background: running ? (paused ? "#e5c185" : "#74a892") : "rgba(255,255,255,0.2)",
                border: "1px solid rgba(255,255,255,0.3)",
              }}
            >
              {running ? (paused ? "âšâš Paused" : "â— Running") : "â—‹ Idle"}
            </div>
            <div style={{ fontSize: "9px", marginTop: "2px", opacity: 0.8 }}>â± {uptime}</div>
          </div>
        </div>

        {errorMsg && (
          <div
            style={{
              marginTop: "8px",
              padding: "5px 8px",
              background: "#fbf2c4",
              color: "#c7522a",
              borderRadius: "6px",
              fontSize: "9px",
              border: "1px solid #e5c185",
            }}
          >
            âš ï¸ {errorMsg}
          </div>
        )}
      </div>

      {/* CONTENT */}
      <div style={{ flex: 1, overflowY: "auto", padding: "8px", display: "flex", flexDirection: "column", gap: "6px" }}>
        
        {/* STATS */}
        <div style={{ background: "white", borderRadius: "8px", padding: "8px", border: "1px solid #e5e5e5" }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "center", gap: "4px", marginBottom: "6px" }}>
            <IconChart size={16} color="#000" />
            <span style={{ fontSize: "10px", fontWeight: "600", color: "#173a35" }}>Stats</span>
            <span style={{ fontSize: "7px", color: "#74a892" }}>â— Live</span>
          </div>

          <div style={{ 
            fontSize: "9px", 
            color: "#173a35", 
            display: "flex", 
            flexWrap: "wrap", 
            justifyContent: "center",
            alignItems: "center",
            gap: "10px"
          }}>
            <span><strong style={{ color: "#008585" }}>{stats.chatsProcessed}</strong> processed</span>
            <span><strong style={{ color: "#74a892" }}>{stats.repliesSent}</strong> replied</span>
            <span><strong style={{ color: "#c7522a" }}>{stats.leadsFound}</strong> leads</span>
            <span><strong>{storageStats.conversationCount}</strong> convos</span>
            <span><strong>{storageStats.totalMessages}</strong> msgs</span>
          </div>

          {useGroq && tokenLimit > 0 && (
            <div style={{ background: "#f8f9fa", padding: "6px", borderRadius: "4px", marginTop: "6px" }}>
              <div style={{ display: "flex", justifyContent: "space-between", marginBottom: "2px" }}>
                <span style={{ fontSize: "7px", color: "#6c757d", textTransform: "uppercase" }}>Tokens</span>
                <span style={{ fontSize: "7px", fontWeight: "600", color: "#173a35" }}>
                  {stats.tokensUsed.toLocaleString()} / {tokenLimit.toLocaleString()}
                </span>
              </div>
              <div style={{ width: "100%", height: "3px", background: "#dee2e6", borderRadius: "2px", overflow: "hidden" }}>
                <div
                  style={{
                    width: `${tokenPercent}%`,
                    height: "100%",
                    background: tokenPercent > 80 ? "#c7522a" : tokenPercent > 50 ? "#e5c185" : "#74a892",
                    transition: "width 0.3s ease",
                  }}
                />
              </div>
            </div>
          )}
        </div>

        {/* CONTROLS */}
        <div style={{ background: "white", borderRadius: "8px", padding: "8px", border: "1px solid #e5e5e5" }}>
          <div style={{ display: "flex", alignItems: "center", justifyContent: "center", gap: "4px", marginBottom: "6px" }}>
            <IconControls size={16} color="#000" />
            <span style={{ fontSize: "10px", fontWeight: "600", color: "#173a35" }}>Controls</span>
          </div>

          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "6px", marginBottom: "6px" }}>
            <div>
              <label style={{ fontSize: "8px", color: "#6c757d", display: "block", marginBottom: "2px" }}>Target chats</label>
              <input
                type="number"
                min={1}
                max={50}
                value={nChats}
                onChange={(e) => setNChats(Number(e.target.value))}
                disabled={running}
                style={{
                  width: "100%",
                  padding: "5px",
                  border: "1px solid #dee2e6",
                  borderRadius: "4px",
                  fontSize: "10px",
                  fontFamily: "monospace",
                }}
              />
            </div>

            <div>
              <label style={{ fontSize: "8px", color: "#6c757d", display: "block", marginBottom: "2px" }}>
                {useGroq ? "Groq Model" : "OpenAI Model"}
              </label>
              {useGroq ? (
                <select
                  value={groqModel}
                  onChange={(e) => handleGroqModelChange(e.target.value)}
                  disabled={running}
                  style={{
                    width: "100%",
                    padding: "5px",
                    border: "1px solid #dee2e6",
                    borderRadius: "4px",
                    fontSize: "9px",
                    background: "white",
                  }}
                >
                  <option value="openai/gpt-oss-120b">GPT-OSS 120B</option>
                  <option value="llama-3.3-70b-versatile">Llama 3.3 70B</option>
                  <option value="meta-llama/llama-4-scout-17b-16e-instruct">Llama 4 Scout</option>
                  <option value="meta-llama/llama-4-maverick-17b-128e-instruct">Llama 4 Maverick</option>
                  <option value="moonshotai/kimi-k2-instruct-0905">Kimi K2</option>
                  <option value="qwen/qwen3-32b">Qwen 3 32B</option>
                </select>
              ) : (
                <select
                  value={model}
                  onChange={(e) => handleModelChange(e.target.value)}
                  disabled={running}
                  style={{
                    width: "100%",
                    padding: "5px",
                    border: "1px solid #dee2e6",
                    borderRadius: "4px",
                    fontSize: "10px",
                    background: "white",
                  }}
                >
                  <option value="gpt-4o-mini">GPT-4o mini</option>
                  <option value="gpt-4o">GPT-4o</option>
                </select>
              )}
            </div>
          </div>

          {/* TOGGLES */}
          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: "4px", marginBottom: "6px" }}>
            <ToggleRow
              label="Groq"
              sublabel={useGroq ? "Fast" : "OpenAI"}
              enabled={useGroq}
              disabled={running}
              onToggle={() => !running && handleUseGroqChange(!useGroq)}
            />
            <ToggleRow
              label="Hours"
              sublabel={strictHours ? "9-6" : "24/7"}
              enabled={strictHours}
              disabled={running}
              onToggle={() => !running && handleStrictHoursChange(!strictHours)}
            />
            <ToggleRow
              label="Preview"
              sublabel={replyPreviewEnabled ? "On" : "Off"}
              enabled={replyPreviewEnabled}
              disabled={running}
              onToggle={() => !running && handleReplyPreviewChange(!replyPreviewEnabled)}
            />
          </div>

          {/* ACTION BUTTONS */}
          <div style={{ display: "flex", gap: "4px" }}>
            <button
              onClick={openOptionsPage}
              style={{
                flex: 1,
                padding: "7px",
                background: "#e5c185",
                border: "none",
                borderRadius: "5px",
                fontSize: "10px",
                fontWeight: "500",
                color: "#173a35",
                cursor: "pointer",
              }}
            >
              Settings
            </button>

            {!running ? (
              <button
                onClick={handleStart}
                disabled={!!errorMsg}
                style={{
                  flex: 2,
                  padding: "7px",
                  background: errorMsg ? "#dee2e6" : "#008585",
                  border: "none",
                  borderRadius: "5px",
                  fontSize: "10px",
                  fontWeight: "500",
                  color: "white",
                  cursor: errorMsg ? "not-allowed" : "pointer",
                }}
              >
                â–¶ Start
              </button>
            ) : (
              <>
                <button
                  onClick={paused ? handleResume : handlePause}
                  style={{
                    flex: 1,
                    padding: "7px",
                    background: paused ? "#74a892" : "#e5c185",
                    border: "none",
                    borderRadius: "5px",
                    fontSize: "10px",
                    fontWeight: "500",
                    color: paused ? "white" : "#173a35",
                    cursor: "pointer",
                  }}
                >
                  {paused ? "â–¶" : "âšâš"}
                </button>
                <button
                  onClick={handleStop}
                  style={{
                    flex: 1,
                    padding: "7px",
                    background: "#c7522a",
                    border: "none",
                    borderRadius: "5px",
                    fontSize: "10px",
                    fontWeight: "500",
                    color: "white",
                    cursor: "pointer",
                  }}
                >
                  â–  Stop
                </button>
              </>
            )}
          </div>

          {/* UTILITY BUTTONS */}
          <div style={{ display: "flex", gap: "4px", marginTop: "4px" }}>
            <button
              onClick={handleExportConversations}
              disabled={running || storageStats.conversationCount === 0}
              style={{
                flex: 1,
                padding: "5px",
                background: "#f8f9fa",
                border: "1px solid #dee2e6",
                borderRadius: "4px",
                fontSize: "8px",
                color: running || storageStats.conversationCount === 0 ? "#adb5bd" : "#000",
                cursor: running || storageStats.conversationCount === 0 ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "4px",
              }}
            >
              <IconExport size={14} color={running || storageStats.conversationCount === 0 ? "#adb5bd" : "#000"} />
              Export
            </button>
            <button
              onClick={handleClearStorage}
              disabled={running || storageStats.conversationCount === 0}
              style={{
                flex: 1,
                padding: "5px",
                background: "#f8f9fa",
                border: "1px solid #dee2e6",
                borderRadius: "4px",
                fontSize: "8px",
                color: running || storageStats.conversationCount === 0 ? "#adb5bd" : "#000",
                cursor: running || storageStats.conversationCount === 0 ? "not-allowed" : "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                gap: "4px",
              }}
            >
              <IconDelete size={14} color={running || storageStats.conversationCount === 0 ? "#adb5bd" : "#000"} />
              Clear ({storageStats.conversationCount})
            </button>
          </div>
        </div>

        {/* TERMINAL */}
        <div
          className="terminal-wrapper"
          style={{
            background: "#1a1f1e",
            borderRadius: "8px",
            overflow: "hidden",
            border: "1px solid #2a2f2e",
            flex: 1,
            display: "flex",
            flexDirection: "column",
            minHeight: "160px",
          }}
        >
          <div
            style={{
              padding: "6px 10px",
              borderBottom: "1px solid rgba(255,255,255,0.1)",
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
            }}
          >
            <div style={{ display: "flex", alignItems: "center", gap: "4px" }}>
              <IconTerminal size={14} color="#74a892" />
              <span style={{ fontSize: "9px", color: "#74a892", fontWeight: "600" }}>Live Terminal</span>
            </div>
            <div style={{ display: "flex", alignItems: "center", gap: "6px" }}>
              <button
                onClick={handleCopyLogs}
                disabled={logs.length === 0}
                style={{
                  padding: "3px 6px",
                  background: copied ? "#74a892" : "rgba(255,255,255,0.1)",
                  border: "1px solid rgba(255,255,255,0.2)",
                  borderRadius: "3px",
                  fontSize: "8px",
                  color: "#fbf2c4",
                  cursor: logs.length === 0 ? "not-allowed" : "pointer",
                  opacity: logs.length === 0 ? 0.5 : 1,
                }}
              >
                {copied ? "âœ“" : "Copy"}
              </button>
              <span style={{ fontSize: "7px", color: "#6c757d" }}>{logs.length}</span>
            </div>
          </div>

          <div
            ref={logContainerRef}
            className="log-container"
            style={{
              flex: 1,
              overflowY: "auto",
              padding: "8px",
              fontFamily: "monospace",
              fontSize: "9px",
              lineHeight: "1.4",
              color: "#fbf2c4",
            }}
          >
            {logs.length === 0 && <div style={{ opacity: 0.5, fontStyle: "italic" }}>Ready.</div>}
            {logs.map((log, i) => {
              const isDoubleText = log.message.includes("Double-texting") || log.message.includes("double-text");
              const isProfileLog = log.message.includes("(") && log.message.includes("@");
              const isStorageLog = log.message.includes("Saved") && log.message.includes("messages");

              return (
                <div key={i} style={{ display: "flex", gap: "6px", marginBottom: "2px" }}>
                  <span style={{ opacity: 0.5, minWidth: "55px", fontSize: "8px" }}>
                    {new Date(log.time).toLocaleTimeString([], { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" })}
                  </span>
                  <span
                    style={{
                      opacity: 0.7,
                      minWidth: "35px",
                      fontSize: "8px",
                      color: log.actor === "Bot" ? "#74a892" : log.actor === "User" ? "#e5c185" : "#fbf2c4",
                    }}
                  >
                    {log.actor}
                  </span>
                  <span
                    style={{
                      opacity: log.type === "ERROR" ? 1 : 0.85,
                      color: log.type === "ERROR" ? "#c7522a" : isDoubleText ? "#e5c185" : "inherit",
                      fontWeight: isDoubleText || isStorageLog ? "600" : "normal",
                      fontSize: "8px",
                    }}
                  >
                    {isDoubleText && "ðŸ’¬ "}
                    {isProfileLog && "ðŸ‘¤ "}
                    {isStorageLog && "ðŸ’¾ "}
                    {log.message}
                  </span>
                </div>
              );
            })}
          </div>
        </div>

        <div style={{ textAlign: "center", fontSize: "7px", color: "#6c757d" }}>v2.6.0 â€¢ LinkedIn Autoresponder</div>
      </div>
    </div>
  );
};

// --- ICON COMPONENTS ---

function IconChart({ size = 16, color = "#000" }: { size?: number; color?: string }) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none">
      <path 
        fill={color} 
        d="M13 3a2 2 0 0 1 1.995 1.85L15 5v16H9V5a2 2 0 0 1 1.85-1.995L11 3zm7 5a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-3V8zM7 11v10H4a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2z"
      />
    </svg>
  );
}

function IconControls({ size = 16, color = "#000" }: { size?: number; color?: string }) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none">
      <path 
        fill={color} 
        d="M16 15c1.306 0 2.418.835 2.83 2H20a1 1 0 1 1 0 2h-1.17a3.001 3.001 0 0 1-5.66 0H4a1 1 0 1 1 0-2h9.17A3.001 3.001 0 0 1 16 15M8 9a3 3 0 0 1 2.762 1.828l.067.172H20a1 1 0 0 1 .117 1.993L20 13h-9.17a3.001 3.001 0 0 1-5.592.172L5.17 13H4a1 1 0 0 1-.117-1.993L4 11h1.17A3.001 3.001 0 0 1 8 9m8-6c1.306 0 2.418.835 2.83 2H20a1 1 0 1 1 0 2h-1.17a3.001 3.001 0 0 1-5.66 0H4a1 1 0 0 1 0-2h9.17A3.001 3.001 0 0 1 16 3"
      />
    </svg>
  );
}

function IconTerminal({ size = 16, color = "#000" }: { size?: number; color?: string }) {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none">
      <path 
        fill={color} 
        fillRule="evenodd"
        d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2zm-3 11h-2a1 1 0 1 0 0 2h2a1 1 0 1 0 0-2M9.05 8.465a1 1 0 0 0-1.497 1.32l.083.094L9.757 12l-2.12 2.121a1 1 0 0 0 1.32 1.498l.093-.083 2.829-2.829a1 1 0 0 0 .083-1.32l-.083-.094z"
      />
    </svg>
  );
}

function IconExport({ size = 14, color = "#000" }: { size?: number; color?: string }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" fill={color}>
    <path d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z"/>
    </svg>
  );
}

function IconDelete({ size = 14, color = "#000" }: { size?: number; color?: string }) {
  return (
    <svg width={size} height={size} viewBox="0 0 24 24" fill={color}>
      <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
    </svg>
  );
}

// --- HELPER COMPONENTS ---

function ToggleRow(props: {
  label: string;
  sublabel: string;
  enabled: boolean;
  disabled: boolean;
  onToggle: () => void;
}) {
  return (
    <div
      onClick={props.onToggle}
      style={{
        background: "#f8f9fa",
        padding: "5px 6px",
        borderRadius: "4px",
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        cursor: props.disabled ? "not-allowed" : "pointer",
        opacity: props.disabled ? 0.6 : 1,
      }}
    >
      <div>
        <div style={{ fontSize: "8px", fontWeight: "500", color: "#173a35" }}>{props.label}</div>
        <div style={{ fontSize: "6px", color: "#6c757d" }}>{props.sublabel}</div>
      </div>
      <div
        style={{
          width: "24px",
          height: "12px",
          background: props.enabled ? "#008585" : "#dee2e6",
          borderRadius: "6px",
          position: "relative",
          transition: "background 0.2s",
        }}
      >
        <div
          style={{
            width: "8px",
            height: "8px",
            background: "white",
            borderRadius: "50%",
            position: "absolute",
            top: "2px",
            left: props.enabled ? "14px" : "2px",
            transition: "left 0.2s",
            boxShadow: "0 1px 2px rgba(0,0,0,0.2)",
          }}
        />
      </div>
    </div>
  );
}

function SummaryRow(props: { label: string; value: string | number; valueColor: string; small?: boolean }) {
  return (
    <div style={{ display: "flex", justifyContent: "space-between", padding: "8px", background: "#f8f9fa", borderRadius: "6px" }}>
      <span style={{ fontSize: "11px", color: "#6c757d" }}>{props.label}:</span>
      <span style={{ fontSize: props.small ? "10px" : "11px", fontWeight: "600", color: props.valueColor }}>{props.value}</span>
    </div>
  );
}

// --- RENDER ---

const root = createRoot(document.getElementById("popup-root")!);
root.render(<Popup />);

====================================================================================================
FILE: src/shared/conversationStorage.ts
====================================================================================================

// linkedinresponder/src/shared/conversationStorage.ts

import { ConversationHistory, MessageEntry, StoredConversations, LeadProfile } from "./types";

const STORAGE_KEY = "conversation_histories";
const MAX_MESSAGES_PER_CONVO = 500;
const SYNC_COOLDOWN = 60000; // 1 minute
const PROFILE_REFRESH_INTERVAL = 86400000; // 24 hours

export function generateLeadId(leadName: string, profileUrl: string): string {
  const combined = `${leadName}_${profileUrl}`;
  // âœ… FIX: Handle unicode characters (JosÃ©, ç”°ä¸­, MÃ¼ller, etc.)
  return btoa(unescape(encodeURIComponent(combined))).substring(0, 32);
}

export async function loadAllConversations(): Promise<StoredConversations> {
  return new Promise((resolve) => {
    chrome.storage.local.get([STORAGE_KEY], (result) => {
      resolve(result[STORAGE_KEY] || {});
    });
  });
}

export async function loadConversation(leadId: string): Promise<ConversationHistory | null> {
  const allConvos = await loadAllConversations();
  return allConvos[leadId] || null;
}

export async function saveConversation(conversation: ConversationHistory): Promise<void> {
  const allConvos = await loadAllConversations();
  
  if (conversation.messages.length > MAX_MESSAGES_PER_CONVO) {
    conversation.messages = conversation.messages.slice(-MAX_MESSAGES_PER_CONVO);
  }
  
  allConvos[conversation.leadId] = conversation;
  
  return new Promise((resolve) => {
    chrome.storage.local.set({ [STORAGE_KEY]: allConvos }, () => {
      resolve();
    });
  });
}

export function shouldResync(conversation: ConversationHistory | null): boolean {
  if (!conversation) return true;
  const timeSinceLastSync = Date.now() - conversation.metadata.lastSyncedAt;
  return timeSinceLastSync > SYNC_COOLDOWN;
}

export function shouldRefreshProfile(profile: LeadProfile | null): boolean {
  if (!profile) return true;
  const timeSinceLastScrape = Date.now() - profile.lastScraped;
  return timeSinceLastScrape > PROFILE_REFRESH_INTERVAL;
}

export async function deleteConversation(leadId: string): Promise<void> {
  const allConvos = await loadAllConversations();
  delete allConvos[leadId];
  
  return new Promise((resolve) => {
    chrome.storage.local.set({ [STORAGE_KEY]: allConvos }, () => {
      resolve();
    });
  });
}

export async function getStorageStats(): Promise<{ count: number; totalMessages: number }> {
  const allConvos = await loadAllConversations();
  const count = Object.keys(allConvos).length;
  const totalMessages = Object.values(allConvos).reduce(
    (sum, convo) => sum + convo.messages.length, 
    0
  );
  return { count, totalMessages };
}

====================================================================================================
FILE: src/shared/doubleTextHandler.ts
====================================================================================================

export interface DoubleTextPattern {
  firstMessage: string;
  secondMessage: string;
  delayMs: number;
  pattern: string;
}

type Context = { messageCount: number; lastMessageQuestions: number };

export function shouldDoubleText(reply: string, ctx: Context): boolean {
  const isLong = reply.split(" ").length > 40;
  const theyAskedQuestions = ctx.lastMessageQuestions > 0;
  return isLong || theyAskedQuestions;
}

export function generateDoubleText(originalReply: string, ctx: Context): DoubleTextPattern | null {
  const patterns = [tryPriceBreakdown, tryAfterThought, tryQuestionRefinement, tryEmojiFollowup];
  for (const pattern of patterns) {
    const result = pattern(originalReply);
    if (result) return result;
  }
  return null;
}

function tryPriceBreakdown(reply: string): DoubleTextPattern | null {
  const sentences = reply.split(/[.!?]/).filter((s) => s.trim());
  if (sentences.length < 3) return null;
  const splitPoint = Math.floor(sentences.length / 2);
  const first = sentences.slice(0, splitPoint).join(". ").trim();
  const second = sentences.slice(splitPoint).join(". ").trim();
  if (first.length < 20 || second.length < 10) return null;
  return {
    firstMessage: first,
    secondMessage: second,
    delayMs: 3000 + Math.random() * 4000,
    pattern: "price_breakdown",
  };
}

function tryAfterThought(reply: string): DoubleTextPattern | null {
  const sentences = reply.split(/[.!?]/).filter((s) => s.trim());
  if (sentences.length < 2) return null;
  const first = sentences[0].trim();
  const rest = sentences.slice(1).join(". ").trim();
  const prefixes = ["Quick note:", "Also,", "One more thing:"];
  const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
  return {
    firstMessage: first,
    secondMessage: `${prefix} ${rest.charAt(0).toLowerCase()}${rest.slice(1)}`,
    delayMs: 5000 + Math.random() * 3000,
    pattern: "afterthought",
  };
}

function tryQuestionRefinement(reply: string): DoubleTextPattern | null {
  if (!reply.includes("?")) return null;
  if (!reply.trim().endsWith("?")) return null;
  const refinements = ["No rushâ€”ballpark is fine.", "Roughly is okay.", "Just an estimate works."];
  return {
    firstMessage: reply.trim(),
    secondMessage: refinements[Math.floor(Math.random() * refinements.length)],
    delayMs: 1800 + Math.random() * 1200,
    pattern: "question_refinement",
  };
}

function tryEmojiFollowup(reply: string): DoubleTextPattern | null {
  if (reply.split(" ").length > 15) return null;
  if (/[.!?]$/.test(reply.trim())) return null; // donâ€™t add emoji if already punctuated
  const affirmatives = [/^(yeah|yes|yep|sure|sounds good|makes sense|got it|perfect)/i];
  const isAffirmative = affirmatives.some((p) => p.test(reply));
  if (!isAffirmative) return null;
  const emojis = ["ðŸ‘", "ðŸ‘Œ", "âœ…"];
  return {
    firstMessage: reply.trim(),
    secondMessage: emojis[Math.floor(Math.random() * emojis.length)],
    delayMs: 1500 + Math.random() * 1500,
    pattern: "emoji_followup",
  };
}

export function calculateDoubleTextDelay(pattern: string): number {
  const base: Record<string, number> = {
    price_breakdown: 3000,
    afterthought: 5000,
    question_refinement: 1800,
    emoji_followup: 1500,
  };
  const v = base[pattern] ?? 3000;
  const variance = v * 0.4;
  return v + (Math.random() - 0.5) * 2 * variance;
}

====================================================================================================
FILE: src/shared/profileScraper.ts
====================================================================================================

// linkedinresponder/src/shared/profileScraper.ts
import { LeadProfile } from "./types";

const SELECTORS = {
  headline: [
    '.pv-text-details__left-panel h2',
    '.text-body-medium.break-words',
    'div[data-view-name="profile-headline"]',
    '.pv-top-card--list-bullet .text-body-small'
  ],
  jobTitle: [
    '.pv-text-details__left-panel .text-body-small:first-of-type',
    '.pv-top-card--list-bullet .text-body-small:first-child'
  ],
  company: [
    '.pv-text-details__left-panel .text-body-small.inline a',
    'a[data-field="experience_company_logo"]',
    '.experience-item__company'
  ],
  location: [
    '.pv-text-details__left-panel .text-body-small:last-of-type',
    'span.text-body-small.inline.t-black--light.break-words',
    '.pv-top-card--list-bullet .text-body-small:last-child'
  ],
  connectionDegree: [
    '.dist-value',
    'span.dist-value',
    '.pv-top-card--list-bullet span.dist-value'
  ]
};

const STATUS_PATTERNS = /(status is (online|offline|reachable|active now))/i;

function getTextFromSelectors(selectors: string[]): string {
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element?.textContent?.trim()) {
      return element.textContent.trim();
    }
  }
  return "";
}

function cleanHeadline(raw: string): string {
  if (!raw) return "";
  // Remove status/online noise lines
  const cleaned = raw
    .split("\n")
    .map((s) => s.trim())
    .filter((s) => s && !STATUS_PATTERNS.test(s.toLowerCase()))
    .join(" ")
    .replace(/\s+/g, " ")
    .trim();
  // If too short or only noise, mark unknown
  const words = cleaned.split(" ").filter(Boolean);
  if (words.length < 3) return "Unknown";
  return cleaned;
}

function extractHeadline(): string {
  let headline = getTextFromSelectors(SELECTORS.headline);
  if (!headline) {
    const sidebarHeadline = document.querySelector('.msg-thread__link-to-profile')?.textContent?.trim();
    if (sidebarHeadline) headline = sidebarHeadline;
  }
  return cleanHeadline(headline);
}

function extractJobTitle(): string {
  const jt = getTextFromSelectors(SELECTORS.jobTitle).replace(/^at\s+/i, "").trim();
  return jt || "Unknown";
}

function extractCompany(): string {
  let company = getTextFromSelectors(SELECTORS.company);
  company = company.replace(/^at\s+/i, "").trim();
  return company || "Unknown";
}

function extractLocation(): string {
  return getTextFromSelectors(SELECTORS.location) || "Unknown";
}

function extractConnectionDegree(): string {
  let degree = getTextFromSelectors(SELECTORS.connectionDegree);
  const match = degree.match(/(\d+(?:st|nd|rd|th))/);
  if (match) return match[1];
  return degree || "Unknown";
}

export function scrapeLeadProfile(): LeadProfile {
  const profile: LeadProfile = {
    headline: extractHeadline(),
    jobTitle: extractJobTitle(),
    company: extractCompany(),
    location: extractLocation(),
    connectionDegree: extractConnectionDegree(),
    lastScraped: Date.now()
  };
  return profile;
}

export function formatProfileForDisplay(leadName: string, profile: LeadProfile | null): string {
  if (!profile) return leadName;
  const parts: string[] = [];
  if (profile.jobTitle && profile.jobTitle !== "Unknown") parts.push(profile.jobTitle);
  if (profile.company && profile.company !== "Unknown") parts.push(`@ ${profile.company}`);
  if (profile.location && profile.location !== "Unknown") parts.push(profile.location);
  const suffix = parts.length > 0 ? ` (${parts.join(", ")})` : "";
  return `${leadName}${suffix}`;
}

export function formatProfileForAI(profile: LeadProfile | null): string {
  if (!profile) return "Profile: Not available";
  const parts: string[] = [];
  if (profile.headline && profile.headline !== "Unknown") parts.push(`Headline: ${profile.headline}`);
  if (profile.jobTitle && profile.jobTitle !== "Unknown") parts.push(`Job Title: ${profile.jobTitle}`);
  if (profile.company && profile.company !== "Unknown") parts.push(`Company: ${profile.company}`);
  if (profile.location && profile.location !== "Unknown") parts.push(`Location: ${profile.location}`);
  if (profile.connectionDegree && profile.connectionDegree !== "Unknown") parts.push(`Connection: ${profile.connectionDegree}`);
  return parts.length ? parts.join(" | ") : "Profile: Not available";
}


====================================================================================================
FILE: src/shared/sendEmail.ts
====================================================================================================

// src/shared/sendEmail.ts
import { getBotSettings, AIProvider } from "./settings";

// Disengagement patterns for quick checks
const DISENGAGEMENT_PATTERNS = [
  "not interested",
  "no thanks",
  "no thank",
  "not now",
  "too busy",
  "maybe later",
  "not a fit",
  "no overlap",
  "policy",
  "not allowed",
  "stop",
  "unsubscribe",
  "no, thank you",
  "no thank you",
  "no thankyou",
  "nope",
  "nah",
];

const SHORT_ACK_PATTERNS = ["sure", "ok", "okay", "k", "thx", "thanks"];

function getApiUrl(provider: AIProvider): string {
  return provider === "groq"
    ? "https://api.groq.com/openai/v1/chat/completions"
    : "https://api.openai.com/v1/chat/completions";
}

function getModelForProvider(provider: AIProvider): string {
  return provider === "groq" ? "llama-3.3-70b-versatile" : "gpt-4o-mini";
}

// Existing function: Should reply to conversation
export async function shouldReplyToConversation(
  apiKey: string,
  conversation: Array<{ speaker: string; message: string }>,
  leadName: string,
  provider: AIProvider = "openai"
): Promise<{ shouldReply: boolean; reason: string }> {
  if (conversation.length === 0) {
    return { shouldReply: false, reason: "Empty conversation" };
  }

  const lastMessage = conversation[conversation.length - 1];
  const lastMsgLower = lastMessage.message.toLowerCase().trim();

  const theirMessages = conversation.filter((m) => m.speaker !== leadName);
  const myMessages = conversation.filter((m) => m.speaker === leadName);

  // Quick disengagement check
  if (DISENGAGEMENT_PATTERNS.some((p) => lastMsgLower.includes(p))) {
    return { shouldReply: false, reason: "Lead disengaged" };
  }

  // Short ack after close check
  if (SHORT_ACK_PATTERNS.includes(lastMsgLower) && theirMessages.length > 0) {
    const lastTheirMsg = theirMessages[theirMessages.length - 1].message.toLowerCase();
    if (
      lastTheirMsg.includes("no overlap") ||
      lastTheirMsg.includes("reach out if") ||
      lastTheirMsg.includes("feel free to reach out") ||
      lastTheirMsg.includes("not a fit") ||
      lastTheirMsg.includes("no problem") ||
      lastTheirMsg.includes("thanks for letting me know")
    ) {
      return { shouldReply: false, reason: "Ack after close" };
    }
  }

  // Quick positive checks
  const iAskedQuestion = theirMessages.length > 0 && theirMessages[theirMessages.length - 1].message.includes("?");
  const theyResponded = myMessages[myMessages.length - 1] === lastMessage;
  const theirLastIdx = theirMessages.length ? conversation.findIndex((m) => m === theirMessages[theirMessages.length - 1]) : -1;
  const lastIdx = conversation.length - 1;

  if (iAskedQuestion && theyResponded && lastIdx > theirLastIdx) {
    return { shouldReply: true, reason: "They answered my question" };
  }

  const isShortResponse = lastMessage.message.split(" ").length < 20;
  const hasEngagement = theirMessages.length > 0 && myMessages.length > 0;
  if (isShortResponse && hasEngagement && theirMessages.length >= 2) {
    return { shouldReply: true, reason: "Short but engaged response" };
  }

  const positiveSignals = [
    "yes", "yeah", "sure", "absolutely", "definitely", "interested",
    "sounds good", "tell me more", "how does", "what about", "can you",
    "could you", "would love to", "want to know", "curious about", "?"
  ];
  if (positiveSignals.some((s) => lastMsgLower.includes(s))) {
    return { shouldReply: true, reason: "Positive engagement detected" };
  }

  // AI fallback for uncertain cases
  const prompt = `You are analyzing a LinkedIn conversation to decide if a response is needed.

CONVERSATION (last 20 messages):
${conversation.slice(-20).map((m) => `${m.speaker}: ${m.message}`).join("\n")}

CONTEXT: The lead just sent: "${lastMessage.message}"

Rules:
- REPLY if they asked a question, answered my question, or showed interest.
- SKIP if they rejected, said no, not interested, policy/no allowance, or gave a short acknowledgment after my closing message.
- Be biased to REPLY only when there's real engagement; otherwise SKIP.

Respond ONLY with:
REPLY: [one sentence reason]
OR
SKIP: [one sentence reason]`;

  try {
    const apiUrl = getApiUrl(provider);
    const model = getModelForProvider(provider);
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
      body: JSON.stringify({
        model,
        messages: [{ role: "user", content: prompt }],
        temperature: 0.2,
        max_tokens: 60,
      }),
    });

    if (!response.ok) {
      console.error(`âŒ ${provider.toUpperCase()} API error in shouldReplyToConversation: ${response.status}`);
      return { shouldReply: true, reason: "AI check failed - defaulting to reply" };
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content?.trim() || "";
    const shouldReply = content.toUpperCase().startsWith("REPLY");
    const reason = content.split(":")[1]?.trim() || "AI decision";

    return { shouldReply, reason };
  } catch (e) {
    console.error("âŒ AI decision check failed:", e);
    return { shouldReply: true, reason: "AI error - defaulting to engage" };
  }
}

// âœ… NEW: AI-based engagement decision after close
export async function shouldEngageAfterClose(
  apiKey: string,
  recentMessages: string[],
  closeType: "pending_meeting" | "my_close" | "none",
  daysSinceClose: number,
  provider: AIProvider = "openai"
): Promise<{ shouldEngage: boolean; reason: string }> {
  
  // Quick check: if no messages, skip
  if (recentMessages.length === 0) {
    return { shouldEngage: false, reason: "No messages to evaluate" };
  }

  const combinedMessages = recentMessages.join(" ").toLowerCase();
  
  // Quick check: obvious question mark = engage
  if (combinedMessages.includes("?")) {
    return { shouldEngage: true, reason: "Message contains a question" };
  }

  // Quick check: substantial content = engage
  if (combinedMessages.split(/\s+/).length > 15) {
    return { shouldEngage: true, reason: "Substantial message content" };
  }

  // For pending meetings within 7 days, be more lenient
  if (closeType === "pending_meeting" && daysSinceClose <= 7) {
    // AI decides if they're following up to schedule
    const prompt = `You are analyzing LinkedIn messages to decide if we should RESPOND.

CONTEXT: 
- We sent a scheduling link previously
- They confirmed interest and we have a pending meeting
- It's been ${daysSinceClose} day(s) since they confirmed
- They just sent these messages:

${recentMessages.map((m, i) => `${i + 1}. "${m}"`).join("\n")}

QUESTION: Are they following up to schedule, asking a question, or showing engagement?

Consider:
- Casual questions like "how about you?" or "and you?" = ENGAGE
- Greetings followed by "hope you're doing well" type messages = ENGAGE
- Simple "hi" or "hey" with nothing else = might be SKIP
- Any question, even casual = ENGAGE

Reply with ONLY:
ENGAGE: [brief reason]
OR
SKIP: [brief reason]`;

    try {
      const apiUrl = getApiUrl(provider);
      const model = getModelForProvider(provider);
      const response = await fetch(apiUrl, {
        method: "POST",
        headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
        body: JSON.stringify({
          model,
          messages: [{ role: "user", content: prompt }],
          temperature: 0.2,
          max_tokens: 50,
        }),
      });

      if (!response.ok) {
        console.error(`âŒ ${provider.toUpperCase()} API error: ${response.status}`);
        return { shouldEngage: true, reason: "AI check failed - defaulting to engage" };
      }

      const data = await response.json();
      const content = data.choices?.[0]?.message?.content?.trim() || "";
      const shouldEngage = content.toUpperCase().startsWith("ENGAGE");
      const reason = content.split(":")[1]?.trim() || "AI decision";

      return { shouldEngage, reason };
    } catch (e) {
      console.error("âŒ Engagement check failed:", e);
      return { shouldEngage: true, reason: "AI error - defaulting to engage" };
    }
  }

  // For old closes (>7 days) or my_close, be stricter
  if (closeType === "my_close" || daysSinceClose > 7) {
    // Only engage if they have a real question or substantial content
    const wordCount = combinedMessages.split(/\s+/).length;
    if (wordCount <= 5) {
      return { shouldEngage: false, reason: `Short message during cooldown (${daysSinceClose} days)` };
    }
  }

  return { shouldEngage: true, reason: "Default to engage" };
}

// Existing function: Check positive lead
export async function checkPositiveLead(
  apiKey: string,
  leadPrompt: string,
  recentMessages: string[],
  provider: AIProvider = "openai"
): Promise<boolean> {
  const prompt = `You are an AI assistant helping identify qualified leads.
Rule: ${leadPrompt}
Analyze the following two LinkedIn messages: ${recentMessages.join("\n")}
Respond with only one word: "yes" or "no".`;

  try {
    const apiUrl = getApiUrl(provider);
    const model = getModelForProvider(provider);
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: { Authorization: `Bearer ${apiKey}`, "Content-Type": "application/json" },
      body: JSON.stringify({
        model,
        messages: [{ role: "user", content: prompt }],
        temperature: 0,
        max_tokens: 10,
      }),
    });

    if (!response.ok) {
      console.error(`âŒ ${provider.toUpperCase()} API error in checkPositiveLead: ${response.status}`);
      return false;
    }

    const data = await response.json();
    return data.choices?.[0]?.message?.content?.trim().toLowerCase() === "yes";
  } catch (e) {
    console.error("âŒ GPT lead check failed:", e);
    return false;
  }
}

// Lead webhook payload type
export interface LeadWebhookPayload {
  leadName: string;
  profileUrl: string;
  company: string;
  jobTitle: string;
  headline: string;
  conversationHistory: string;
  messageCount: number;
  detectedAt: string;
}

// Existing function: Send lead webhook
export async function sendLeadWebhook(payload: LeadWebhookPayload): Promise<void> {
  const { webhookUrl } = await getBotSettings();

  if (!webhookUrl || webhookUrl.trim().length === 0) {
    throw new Error("Webhook URL is not configured. Please set it in Options.");
  }

  const response = await fetch(webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  if (!response.ok) {
    const errText = await response.text().catch(() => "Unknown error");
    console.error("âŒ Webhook error:", errText);
    throw new Error(`Webhook error: ${response.status}`);
  }

  console.log("âœ… Lead sent to webhook successfully");
}

====================================================================================================
FILE: src/shared/settings.ts
====================================================================================================

// linkedinresponder/src/shared/settings.ts
// Centralized schema + defaults for chrome.storage.local settings.
// Goal: one source of truth for keys/defaults, no logic change.

export type AIProvider = "openai" | "groq";

export type BotSettings = {
  openaiApiKey: string;
  groqApiKey: string;
  webhookUrl: string; // Zapier webhook URL

  replyPrompt: string;
  leadPrompt: string;

  chatMinDelay: number; // ms
  chatMaxDelay: number; // ms
  loopMinDelay: number; // ms
  loopMaxDelay: number; // ms

  // Working hours window (used by content script strictHours toggle)
  startHour: number; // 0-23
  endHour: number; // 0-23

  // Per-function AI provider selection
  replyProvider: AIProvider; // Reply generation
  decisionProvider: AIProvider; // Should-reply decision
  leadDetectionProvider: AIProvider; // Lead qualification
};

export const SETTINGS_KEYS = {
  openaiApiKey: "openaiApiKey",
  groqApiKey: "groqApiKey",
  webhookUrl: "webhookUrl",

  replyPrompt: "replyPrompt",
  leadPrompt: "leadPrompt",

  chatMinDelay: "chatMinDelay",
  chatMaxDelay: "chatMaxDelay",
  loopMinDelay: "loopMinDelay",
  loopMaxDelay: "loopMaxDelay",

  startHour: "startHour",
  endHour: "endHour",

  replyProvider: "replyProvider",
  decisionProvider: "decisionProvider",
  leadDetectionProvider: "leadDetectionProvider",
} as const;

export const DEFAULT_SETTINGS: BotSettings = {
  openaiApiKey: "",
  groqApiKey: "",
  webhookUrl: "",

  replyPrompt:
    "You are {user_name}'s assistant. Reply to this lead based on context:\n{extracted_text}\nReply briefly and professionally.",
  leadPrompt: "Does this conversation indicate strong buying intent or interest? Reply YES or NO.",

  chatMinDelay: 2000,
  chatMaxDelay: 5000,
  loopMinDelay: 10000,
  loopMaxDelay: 30000,

  startHour: 9,
  endHour: 18,

  replyProvider: "groq",
  decisionProvider: "groq",
  leadDetectionProvider: "openai",
};

const VALID_PROVIDERS: AIProvider[] = ["openai", "groq"];

function clampInt(value: unknown, min: number, max: number, fallback: number): number {
  const n = typeof value === "number" ? value : Number(value);
  if (!Number.isFinite(n)) return fallback;
  const i = Math.round(n);
  return Math.min(max, Math.max(min, i));
}

function clampMs(value: unknown, min: number, max: number, fallback: number): number {
  const n = typeof value === "number" ? value : Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.min(max, Math.max(min, Math.floor(n)));
}

function asString(value: unknown, fallback: string): string {
  if (typeof value !== "string") return fallback;
  return value;
}

function asProvider(value: unknown, fallback: AIProvider): AIProvider {
  if (typeof value === "string" && VALID_PROVIDERS.includes(value as AIProvider)) {
    return value as AIProvider;
  }
  return fallback;
}

function normalizePrompt(value: string): string {
  return value;
}

function normalizeUrl(value: string): string {
  return value.trim();
}

export async function getBotSettings(): Promise<BotSettings> {
  return new Promise((resolve) => {
    chrome.storage.local.get(Object.values(SETTINGS_KEYS), (raw) => {
      const chatMinDelay = clampMs(raw[SETTINGS_KEYS.chatMinDelay], 250, 60_000, DEFAULT_SETTINGS.chatMinDelay);
      const chatMaxDelay = clampMs(raw[SETTINGS_KEYS.chatMaxDelay], 250, 120_000, DEFAULT_SETTINGS.chatMaxDelay);
      const loopMinDelay = clampMs(raw[SETTINGS_KEYS.loopMinDelay], 500, 600_000, DEFAULT_SETTINGS.loopMinDelay);
      const loopMaxDelay = clampMs(raw[SETTINGS_KEYS.loopMaxDelay], 500, 600_000, DEFAULT_SETTINGS.loopMaxDelay);

      // Ensure min <= max without changing intent
      const safeChatMin = Math.min(chatMinDelay, chatMaxDelay);
      const safeChatMax = Math.max(chatMinDelay, chatMaxDelay);
      const safeLoopMin = Math.min(loopMinDelay, loopMaxDelay);
      const safeLoopMax = Math.max(loopMinDelay, loopMaxDelay);

      const startHour = clampInt(raw[SETTINGS_KEYS.startHour], 0, 23, DEFAULT_SETTINGS.startHour);
      const endHour = clampInt(raw[SETTINGS_KEYS.endHour], 0, 23, DEFAULT_SETTINGS.endHour);

      const settings: BotSettings = {
        openaiApiKey: asString(raw[SETTINGS_KEYS.openaiApiKey], DEFAULT_SETTINGS.openaiApiKey).trim(),
        groqApiKey: asString(raw[SETTINGS_KEYS.groqApiKey], DEFAULT_SETTINGS.groqApiKey).trim(),
        webhookUrl: normalizeUrl(asString(raw[SETTINGS_KEYS.webhookUrl], DEFAULT_SETTINGS.webhookUrl)),

        replyPrompt: normalizePrompt(asString(raw[SETTINGS_KEYS.replyPrompt], DEFAULT_SETTINGS.replyPrompt)),
        leadPrompt: normalizePrompt(asString(raw[SETTINGS_KEYS.leadPrompt], DEFAULT_SETTINGS.leadPrompt)),

        chatMinDelay: safeChatMin,
        chatMaxDelay: safeChatMax,
        loopMinDelay: safeLoopMin,
        loopMaxDelay: safeLoopMax,

        startHour,
        endHour,

        replyProvider: asProvider(raw[SETTINGS_KEYS.replyProvider], DEFAULT_SETTINGS.replyProvider),
        decisionProvider: asProvider(raw[SETTINGS_KEYS.decisionProvider], DEFAULT_SETTINGS.decisionProvider),
        leadDetectionProvider: asProvider(raw[SETTINGS_KEYS.leadDetectionProvider], DEFAULT_SETTINGS.leadDetectionProvider),
      };

      resolve(settings);
    });
  });
}

export async function setBotSettings(partial: Partial<BotSettings>): Promise<void> {
  const patch: Record<string, unknown> = {};

  if (partial.openaiApiKey !== undefined) patch[SETTINGS_KEYS.openaiApiKey] = String(partial.openaiApiKey);
  if (partial.groqApiKey !== undefined) patch[SETTINGS_KEYS.groqApiKey] = String(partial.groqApiKey);
  if (partial.webhookUrl !== undefined) patch[SETTINGS_KEYS.webhookUrl] = String(partial.webhookUrl);

  if (partial.replyPrompt !== undefined) patch[SETTINGS_KEYS.replyPrompt] = String(partial.replyPrompt);
  if (partial.leadPrompt !== undefined) patch[SETTINGS_KEYS.leadPrompt] = String(partial.leadPrompt);

  if (partial.chatMinDelay !== undefined) patch[SETTINGS_KEYS.chatMinDelay] = partial.chatMinDelay;
  if (partial.chatMaxDelay !== undefined) patch[SETTINGS_KEYS.chatMaxDelay] = partial.chatMaxDelay;
  if (partial.loopMinDelay !== undefined) patch[SETTINGS_KEYS.loopMinDelay] = partial.loopMinDelay;
  if (partial.loopMaxDelay !== undefined) patch[SETTINGS_KEYS.loopMaxDelay] = partial.loopMaxDelay;

  if (partial.startHour !== undefined) patch[SETTINGS_KEYS.startHour] = partial.startHour;
  if (partial.endHour !== undefined) patch[SETTINGS_KEYS.endHour] = partial.endHour;

  if (partial.replyProvider !== undefined) patch[SETTINGS_KEYS.replyProvider] = partial.replyProvider;
  if (partial.decisionProvider !== undefined) patch[SETTINGS_KEYS.decisionProvider] = partial.decisionProvider;
  if (partial.leadDetectionProvider !== undefined) patch[SETTINGS_KEYS.leadDetectionProvider] = partial.leadDetectionProvider;

  return new Promise((resolve) => {
    chrome.storage.local.set(patch, () => resolve());
  });
}

====================================================================================================
FILE: src/shared/types.ts
====================================================================================================

// linkedinresponder/src/shared/types.ts
//
// NOTE: BotConfig is used for RUNTIME state passed via messages.
// For STORAGE schema, see BotSettings in settings.ts.
// These are intentionally separate to allow flexibility.

export interface BotConfig {
  openaiApiKey: string;
  groqApiKey: string;
  resendApiKey: string;
  model: string;
  groqModel: string;
  useGroq: boolean;
  systemPrompt: string;
  minDelay: number;
  maxDelay: number;
  typingSpeed: number;
  strictWorkingHours: boolean;
  leadNotificationEmail: string;
}

export interface BotStats {
  chatsProcessed: number;
  repliesSent: number;
  leadsFound: number;
  startTime: number | null;
  tokensUsed: number;
  currentModel: string;
}

export interface BotStatus {
  running: boolean;
  stats: BotStats;
  logs: BotLogEntry[];
  currentChat?: string;
}

export interface BotLogEntry {
  time: number;
  actor: string;
  message: string;
  type: 'INFO' | 'ACTION' | 'SUCCESS' | 'ERROR' | 'WARNING' | 'LEAD';
}

export interface BotCommand {
  type: 'GET_STATUS' | 'START_BOT' | 'STOP_BOT';
  config?: {
    nChats: number;
    model: string;
    useGroq: boolean;
    groqModel: string;
    strictHours: boolean;
  };
}

// âœ… Profile information structure
export interface LeadProfile {
  headline: string;
  jobTitle: string;
  company: string;
  location: string;
  connectionDegree: string;
  lastScraped: number;
}

// âœ… Message entry structure
export interface MessageEntry {
  speaker: string;
  content: string;
  timestamp: number;
  type: 'sent' | 'received';
}

// âœ… Conversation history structure
export interface ConversationHistory {
  leadId: string;
  leadName: string;
  profileUrl: string;
  profile: LeadProfile | null;
  messages: MessageEntry[];
  metadata: {
    firstContact: number;
    lastActivity: number;
    lastMessageFrom: 'lead' | 'me';
    totalMessages: number;
    lastSyncedAt: number;
  };
}

export interface StoredConversations {
  [leadId: string]: ConversationHistory;
}


====================================================================================================
FILE: src/shared/utils.ts
====================================================================================================

export function randomBetween(min: number, max: number): number {
  return Math.floor(min + Math.random() * (max - min + 1));
}
export function sleep(ms: number): Promise<void> {
  return new Promise((res) => setTimeout(res, ms));
}
